"""
This file is auto-generated by the openc3 extension to provide intellisense
NOTE: any modifications to this file will not persist between vscode plugin loads
"""

from typing import Any, overload, List, Dict, Tuple, Optional, IO, Iterator, Type

# --- Retrieving User Input ---

@overload
def ask(question: str) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool) -> Any: ...
@overload
def ask(question: str, blank_or_default: Any) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool, password: bool) -> Any: ...
def ask(*args: Any) -> Any:
    """
    Prompts the user for input and automatically converts the string to the
    appropriate data type.

    Args:
        question (str): The question to display to the user.
        blank_or_default (Any): A boolean or default value. If True, a blank
                                input is allowed. If a value is provided, it
                                will be used as the default.
        password (bool): If True, masks the input as a password.

    Returns:
        Any: The user's input, converted to the appropriate data type.
    """
    ...

@overload
def ask_string(question: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool) -> str: ...
@overload
def ask_string(question: str, blank_or_default: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool, password: bool) -> str: ...
def ask_string(*args: Any) -> str:
    """
    Prompts the user for input and always returns the input as a string.

    Args:
        question (str): The question to display to the user.
        blank_or_default (Any): A boolean or default value. If True, a blank
                                input is allowed. If a value is provided, it
                                will be used as the default.
        password (bool): If True, masks the input as a password.

    Returns:
        str: The user's input as a string.
    """
    ...

def message_box(message: str, *button_texts: str) -> str:
    """
    Creates a message box with arbitrary buttons and returns the text of the
    button clicked.

    Args:
        message (str): The message to display in the box.
        *button_texts (str): The text for each button.

    Returns:
        str: The text of the button the user clicked.
    """
    ...

def vertical_message_box(message: str, *button_texts: str) -> str:
    """
    Creates a vertical message box with arbitrary buttons and returns the text
    of the button clicked.

    Args:
        message (str): The message to display in the box.
        *button_texts (str): The text for each button.

    Returns:
        str: The text of the button the user clicked.
    """
    ...

def combo_box(message: str, *selection_texts: str) -> str:
    """
    Creates a combo box with arbitrary selections and returns the text of the
    selection clicked.

    Args:
        message (str): The message to display above the combo box.
        *selection_texts (str): The text for each selection in the combo box.

    Returns:
        str: The text of the selection the user chose.
    """
    ...

# --- Providing Information to the User ---

def prompt(message: str) -> None:
    """
    Displays a message to the user and waits for them to press an OK button.

    Args:
        message (str): The string message to display to the user.

    Returns:
        None: This function does not return a value.
    """
    ...

@overload
def tlm(telemetry_item: str, type: str = CONVERTED) -> Any: ...
@overload
def tlm(
    target_name: str, packet_name: str, item_name: str, type: str = CONVERTED
) -> Any: ...
def tlm(*args: str, **kwargs: str) -> Any:
    """
    Reads the specified form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.
        type (str): The type of value to return (RAW, CONVERTED, FORMATTED, or WITH_UNITS).
                    Defaults to CONVERTED.

    Returns:
        Any: The value of the telemetry item in the specified form.
    """
    ...

@overload
def tlm_raw(telemetry_item: str) -> Any: ...
@overload
def tlm_raw(target_name: str, packet_name: str, item_name: str) -> Any: ...
def tlm_raw(*args: str) -> Any:
    """
    Reads the RAW form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        Any: The raw value of the telemetry item.
    """
    ...

@overload
def tlm_formatted(telemetry_item: str) -> str: ...
@overload
def tlm_formatted(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_formatted(*args: str) -> str:
    """
    Reads the FORMATTED form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        str: The formatted string value of the telemetry item.
    """
    ...

@overload
def tlm_with_units(telemetry_item: str) -> str: ...
@overload
def tlm_with_units(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_with_units(*args: str) -> str:
    """
    Reads the WITH_UNITS form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        str: The string value of the telemetry item including its units.
    """
    ...

@overload
def get_tlm_buffer(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm_buffer(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm_buffer(*args: str) -> Dict[str, Any]:
    """
    Returns a packet hash along with the raw packet buffer.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        Dict[str, Any]: A dictionary containing the packet data, including the raw buffer.
    """
    ...

@overload
def get_tlm_packet(
    telemetry_packet: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
@overload
def get_tlm_packet(
    target_name: str, packet_name: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
def get_tlm_packet(*args: str, **kwargs: str) -> List[Tuple[str, Any, str]]:
    """
    Returns the names, values, and limits states of all telemetry items in a specified packet.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        type (str): The type of value to return. Defaults to CONVERTED.

    Returns:
        List[Tuple[str, Any, str]]: A list of tuples, where each tuple contains
                                    (item_name, item_value, limits_state).
    """
    ...

def get_tlm_available(items: List[str]) -> List[str]:
    """
    Returns the actual items available based on the specified set of telemetry items.

    Args:
        items (List[str]): A list of telemetry item names to check for availability.

    Returns:
        List[str]: A list of the available telemetry item names.
    """
    ...

def get_tlm_values(
    items: List[str],
) -> Tuple[List[Any], List[str], List[Any], List[str]]:
    """
    Returns the values and current limits state for a specified set of telemetry items.

    Args:
        items (List[str]): A list of telemetry item names to retrieve values for.

    Returns:
        Tuple[List[Any], List[str], List[Any], List[str]]: A tuple containing
                                                        (values, limits_states, raw_values, times).
    """
    ...

def get_all_tlm(target_name: str) -> List[Dict[str, Any]]:
    """
    Returns an array of all target packet hashes.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a telemetry packet.
    """
    ...

def get_all_tlm_names(target_name: str) -> List[str]:
    """
    Returns an array of all target packet names.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[str]: A list of strings representing the packet names.
    """
    ...

def get_all_tlm_item_names(target_name: str) -> List[str]:
    """
    Returns all the item names for every packet in a target.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[str]: A list of strings representing the item names.
    """
    ...

@overload
def get_tlm(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm(*args: str) -> Dict[str, Any]:
    """
    Returns a packet hash.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        Dict[str, Any]: A dictionary representing the telemetry packet.
    """
    ...

@overload
def get_item(telemetry_item: str) -> Dict[str, Any]: ...
@overload
def get_item(target_name: str, packet_name: str, item_name: str) -> Dict[str, Any]: ...
def get_item(*args: str) -> Dict[str, Any]:
    """
    Returns an item hash.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        Dict[str, Any]: A dictionary representing the telemetry item.
    """
    ...

@overload
def get_tlm_cnt(telemetry_packet: str) -> int: ...
@overload
def get_tlm_cnt(target_name: str, packet_name: str) -> int: ...
def get_tlm_cnt(*args: str) -> int:
    """
    Returns the number of times a specified telemetry packet has been received.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        int: The receive count for the packet.
    """
    ...

@overload
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None: ...
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None:
    """
    Sets a telemetry item value in the Command and Telemetry Server.

    Args:
        telemetry_item_with_value (str): The name of the telemetry item and its new value
                                        (e.g., "INST HEALTH_STATUS TEMP1 50").
        type (str): The type of value being set. Defaults to CONVERTED.
    """
    ...

@overload
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None: ...
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None:
    """
    Injects a packet into the system.

    Args:
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_hash (Optional[Dict]): A dictionary of item names and values to inject.
                                   If omitted, an empty packet is injected.
        type (str): The type of value being injected. Defaults to CONVERTED.
    """
    ...

@overload
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None: ...
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None:
    """
    Sets the converted value for a telemetry point and maintains it.

    Args:
        telemetry_item_with_value (str): The name of the telemetry item and its new value
                                        (e.g., "INST HEALTH_STATUS TEMP1 50").
        type (str): The override type (e.g., RAW, CONVERTED, or "ALL"). Defaults to "ALL".
    """
    ...

@overload
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None: ...
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None:
    """
    Clears the override of a telemetry point.

    Args:
        telemetry_item (str): The full name of the telemetry item to normalize (e.g., "INST HEALTH_STATUS TEMP1").
        type (str): The override type to normalize (e.g., RAW, CONVERTED, or "ALL"). Defaults to "ALL".
    """
    ...

def get_overrides() -> List[Dict[str, Any]]:
    """
    Returns a list of the currently overridden values.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents an overridden telemetry item.
    """
    ...

# --- Plugins / Packages ---

def plugin_list(default: bool = False) -> List[str]:
    """
    Returns all the installed plugins.

    Args:
        default (bool): If True, returns default plugins as well. Defaults to False.

    Returns:
        List[str]: A list of strings representing the installed plugin names.
    """
    ...

def plugin_get(plugin_name: str) -> Dict[str, Any]:
    """
    Returns information about an installed plugin.

    Args:
        plugin_name (str): The name of the plugin.

    Returns:
        Dict[str, Any]: A dictionary containing information about the plugin.
    """
    ...

def package_list() -> Dict[str, List[str]]:
    """
    Lists all the packages installed in COSMOS.

    Returns:
        Dict[str, List[str]]: A dictionary where keys are package types (e.g., 'gem', 'pip')
                              and values are lists of installed package names.
    """
    ...

# --- Targets ---

def get_target_names() -> List[str]:
    """
    Returns a list of the targets in the system.

    Returns:
        List[str]: A list of strings representing the target names.
    """
    ...

def get_target(target_name: str) -> Dict[str, Any]:
    """
    Returns a target hash containing all the information about the target.

    Args:
        target_name (str): The name of the target.

    Returns:
        Dict[str, Any]: A dictionary containing all information about the target.
    """
    ...

def get_target_interfaces() -> List[Tuple[str, str]]:
    """
    Returns the interfaces for all targets.

    Returns:
        List[Tuple[str, str]]: A list of tuples, where each tuple contains
                               the target name and its associated interface name.
    """
    ...

# --- Interfaces ---

def get_interface(interface_name: str) -> Dict[str, Any]:
    """
    Returns an interface status including the as-built interface and its current status.

    Args:
        interface_name (str): The name of the interface.

    Returns:
        Dict[str, Any]: A dictionary containing the interface's status and configuration.
    """
    ...

def get_interface_names() -> List[str]:
    """
    Returns a list of the interfaces in the system.

    Returns:
        List[str]: A list of strings representing the interface names.
    """
    ...

@overload
def connect_interface(interface_name: str) -> None:
    """
    Connects to targets associated with a COSMOS interface.
    """
    ...

@overload
def connect_interface(interface_name: str, *args: Any) -> None:
    """
    Connects to targets associated with a COSMOS interface with specific parameters.
    """
    ...

def connect_interface(*args: Any, **kwargs: Any) -> None: ...
def disconnect_interface(interface_name: str) -> None:
    """
    Disconnects from targets associated with a COSMOS interface.

    Args:
        interface_name (str): The name of the interface to disconnect.
    """
    ...

def start_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Starts logging of raw data on one or all interfaces.

    Args:
        interface_name (str): The name of the interface to start logging for.
                              Defaults to "ALL" to start logging for all interfaces.
    """
    ...

def stop_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Stops logging of raw data on one or all interfaces.

    Args:
        interface_name (str): The name of the interface to stop logging for.
                              Defaults to "ALL" to stop logging for all interfaces.
    """
    ...

def get_all_interface_info() -> (
    List[Tuple[str, str, int, int, int, int, int, int, int]]
):
    """
    Returns information about all interfaces.

    Returns:
        List[Tuple[str, str, int, int, int, int, int, int, int]]: A list of tuples, where each
        tuple contains the interface name, connection state, number of connected clients, transmit queue size,
        receive queue size, bytes transmitted, bytes received, command count, and telemetry count.
    """
    ...

def map_target_to_interface(
    target_name: str,
    interface_name: str,
    cmd_only: bool = False,
    tlm_only: bool = False,
    unmap_old: bool = True,
) -> None:
    """
    Maps a target to an interface, allowing the interface to process the target's commands and telemetry.

    Args:
        target_name (str): The name of the target.
        interface_name (str): The name of the interface.
        cmd_only (bool): If True, only map target commands to the interface. Defaults to False.
        tlm_only (bool): If True, only map target telemetry to the interface. Defaults to False.
        unmap_old (bool): If True, remove the target from all existing interfaces before mapping.
                          Defaults to True.
    """
    ...

def interface_cmd(
    interface_name: str, command_name: str, command_parameters: Optional[str] = None
) -> None:
    """
    Send a command directly to an interface.
    """
    ...

def interface_protocol_cmd(
    interface_name: str,
    command_name: str,
    command_parameters: Optional[str] = None,
    read_write: str = "READ_WRITE",
    index: int = -1,
) -> None:
    """
    Send a command directly to an interface protocol.
    """
    ...











def script_list() -> List[str]:
    """
    Returns all the available files in COSMOS as a list.
    """
    ...

def script_create(script_name: str, script_contents: str) -> None:
    """
    Creates a new script with the given contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
        script_contents (str): Script contents as text.
    """
    ...

def script_body(script_name: str) -> str:
    """
    Returns the script contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_delete(script_name: str) -> None:
    """
    Deletes a script from COSMOS.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_run(
    script_name: str,
    disconnect: bool = False,
    environment: Optional[Dict[str, str]] = None,
    suite_runner: Optional[Dict[str, str]] = None,
) -> str:
    """
    Runs a script in Script Runner.

    Args:
        script_name (str): Full path name of the script starting with the target.
        disconnect (bool): Whether to run the script in Disconnect mode.
        environment (Optional[Dict[str, str]]): A dictionary of key/value items to set as script environment variables.
        suite_runner (Optional[Dict[str, str]]): A dictionary of suite runner options.

    Returns:
        str: The ID of the started script.
    """
    ...

def script_lock(script_name: str) -> None:
    """
    Locks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_unlock(script_name: str) -> None:
    """
    Unlocks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_syntax_check(script_name: str) -> Dict[str, Any]:
    """
    Performs a Ruby or Python syntax check on the given script.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        Dict[str, Any]: A dictionary containing the syntax check result.
    """
    ...

def script_instrumented(script_name: str) -> str:
    """
    Returns the instrumented script which allows COSMOS Script Runner to monitor
    the execution.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        str: The instrumented script contents.
    """
    ...

def script_delete_all_breakpoints() -> None:
    """
    Deletes all breakpoints associated with all scripts.
    """
    ...

def step_mode() -> None:
    """
    Places ScriptRunner into step mode.
    """
    ...

def run_mode() -> None:
    """
    Places ScriptRunner into run mode.
    """
    ...

def disconnect_script() -> None:
    """
    Puts scripting into disconnect mode.
    """
    ...

def running_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the currently running scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a running script.
    """
    ...

def script_get(script_id: str) -> Dict[str, Any]:
    """
    Gets information on the script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.

    Returns:
        Dict[str, Any]: A dictionary containing information about the script.
    """
    ...

def running_script_stop(script_id: str) -> None:
    """
    Stops the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_pause(script_id: str) -> None:
    """
    Pauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_retry(script_id: str) -> None:
    """
    Retries the current line of the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_go(script_id: str) -> None:
    """
    Unpauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int
) -> None: ...
@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int, end_line_number: int
) -> None: ...
def running_script_execute_while_paused(
    script_id: str,
    script_file_path: str,
    start_line_number: int,
    end_line_number: Optional[int] = None,
) -> None:
    """
    Performs a goto or executes a selection on a running script.

    Args:
        script_id (str): Script ID returned by script_run.
        script_file_path (str): Path to the script file.
        start_line_number (int): The line number to start at.
        end_line_number (Optional[int]): The line number to end at. If given, executes a selection.
    """
    ...

def running_script_step(script_id: str) -> None:
    """
    Steps the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_delete(script_id: str) -> None:
    """
    Force quits the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def completed_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the completed scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a completed script.
    """
    ...

# --- Script Runner Settings ---

def set_line_delay(delay: float) -> None:
    """
    Sets the line delay in Script Runner.

    Args:
        delay (float): The amount of time Script Runner will wait between
                       lines when executing a script, in seconds. Must be >= 0.0.
    """
    ...

def get_line_delay() -> float:
    """
    Gets the line delay that Script Runner is currently using.

    Returns:
        float: The current line delay in seconds.
    """
    ...

def set_max_output(characters: int) -> None:
    """
    Sets the maximum number of characters to display in Script Runner output.

    Args:
        characters (int): The maximum number of characters to output before truncating.
    """
    ...

def get_max_output() -> int:
    """
    Gets the maximum number of characters to display in Script Runner output.

    Returns:
        int: The maximum number of characters.
    """
    ...

def disable_instrumentation() -> Iterator[None]:
    """
    Disables instrumentation (line highlighting and exception catching) for a block of code.
    Use with a 'with' statement.

    Example:
        with disable_instrumentation():
            for x in range(1000):
                # This loop will not be instrumented
                pass
    """
    yield

# --- Timelines ---

from datetime import datetime

def list_timelines() -> List[Dict[str, Any]]:
    """
    Returns a list of all timelines in the system.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a timeline.
    """
    ...

def create_timeline(name: str, color: Optional[str] = None) -> Dict[str, Any]:
    """
    Creates a new timeline in Calendar.

    Args:
        name (str): The name of the timeline.
        color (Optional[str]): The color of the timeline as a hex value (e.g., '#FF0000').
                               Defaults to a random color.

    Returns:
        Dict[str, Any]: A dictionary representing the created timeline.
    """
    ...

def get_timeline(name: str) -> Dict[str, Any]:
    """
    Gets information about an existing timeline.

    Args:
        name (str): The name of the timeline.

    Returns:
        Dict[str, Any]: A dictionary representing the timeline.
    """
    ...

def set_timeline_color(name: str, color: str) -> None:
    """
    Sets the displayed color for an existing timeline.

    Args:
        name (str): The name of the timeline.
        color (str): The color of the timeline as a hex value (e.g., '#4287f5').
    """
    ...

def delete_timeline(name: str, force: bool = False) -> None:
    """
    Deletes an existing timeline.

    Args:
        name (str): The name of the timeline.
        force (bool): If True, deletes the timeline even if it has activities.
                      Defaults to False.
    """
    ...

def create_timeline_activity(
    name: str, kind: str, start: datetime, stop: datetime, data: Dict[str, Any] = {}
) -> Dict[str, Any]:
    """
    Creates an activity on an existing timeline.

    Args:
        name (str): The name of the timeline.
        kind (str): The type of the activity. Must be one of 'COMMAND', 'SCRIPT', or 'RESERVE'.
        start (datetime): The start time of the activity.
        stop (datetime): The stop time of the activity.
        data (Dict[str, Any]): A dictionary of data for COMMAND or SCRIPT activities.
                               Defaults to an empty dictionary.

    Returns:
        Dict[str, Any]: A dictionary representing the created activity.
    """
    ...

def get_timeline_activity(name: str, start: datetime, uuid: str) -> Dict[str, Any]:
    """
    Gets an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.

    Returns:
        Dict[str, Any]: A dictionary representing the activity.
    """
    ...

def get_timeline_activities(
    name: str,
    start: Optional[datetime] = None,
    stop: Optional[datetime] = None,
    limit: Optional[int] = None,
) -> List[Dict[str, Any]]:
    """
    Gets a range of timeline activities.

    Args:
        name (str): The name of the timeline.
        start (Optional[datetime]): The start time of the activities. Defaults to 7 days ago.
        stop (Optional[datetime]): The stop time of the activities. Defaults to 7 days from now.
        limit (Optional[int]): The maximum number of activities to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary represents an activity.
    """
    ...

def delete_timeline_activity(name: str, start: datetime, uuid: str) -> None:
    """
    Deletes an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.
    """
    ...

# --- Metadata ---

def metadata_all(limit: int = 100) -> List[Dict[str, Any]]:
    """
    Returns all the metadata that was previously set.

    Args:
        limit (int): The maximum number of metadata items to return. Defaults to 100.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_get(start: str) -> List[Dict[str, Any]]:
    """
    Returns metadata that was previously set, starting from a specified time.

    Args:
        start (str): Time at which to retrieve metadata as an integer or string
                     representing seconds from epoch.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_set(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Sets metadata which appears in the Calendar tool.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to store as metadata.
        start (Optional[datetime]): Time at which to store the metadata. Defaults to now.
        color (Optional[str]): Color to display the metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_update(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Updates metadata that was previously set.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to update as metadata.
        start (Optional[datetime]): Time at which to update metadata. Defaults to the
                                    latest metadata item.
        color (Optional[str]): Color to display metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_input() -> Dict[str, Any]:
    """
    Prompts the user to set existing metadata values or create a new one.

    Returns:
        Dict[str, Any]: A dictionary containing the metadata entered by the user.
    """
    ...

# --- Settings ---

def list_settings() -> List[str]:
    """
    Returns all the current COSMOS setting names.

    Returns:
        List[str]: A list of strings representing the names of the available settings.
    """
    ...

def get_all_settings() -> Dict[str, Any]:
    """
    Returns all the current COSMOS settings along with their values.

    Returns:
        Dict[str, Any]: A dictionary where keys are setting names and values are
                        dictionaries containing the setting data.
    """
    ...

def get_setting(setting_name: str) -> Optional[Any]:
    """
    Returns the value of a specific COSMOS setting.

    Args:
        setting_name (str): The name of the setting.

    Returns:
        Optional[Any]: The value of the setting, or None if the setting does not exist.
    """
    ...

def get_settings(*setting_names: str) -> List[Optional[Any]]:
    """
    Returns the data from one or more COSMOS settings.

    Args:
        *setting_names (str): The names of the settings to return.

    Returns:
        List[Optional[Any]]: A list containing the values of the requested settings.
                             The order matches the input order.
    """
    ...

def set_setting(setting_name: str, setting_value: Any) -> None:
    """
    Sets the value for a given setting.

    NOTE: This API is only accessible externally (not within Script Runner)
          and requires the admin password.

    Args:
        setting_name (str): The name of the setting to change.
        setting_value (Any): The new value for the setting.
    """
    ...

# --- Configuration ---

def config_tool_names() -> List[str]:
    """
    Returns a list of all available configuration tool names.

    Returns:
        List[str]: A list of strings representing the tool names.
    """
    ...

def list_configs(tool_name: str) -> List[str]:
    """
    Lists all saved configuration names for a given tool.

    Args:
        tool_name (str): The name of the tool.

    Returns:
        List[str]: A list of strings representing the configuration names.
    """
    ...

def load_config(tool_name: str, config_name: str) -> List[Dict[str, Any]]:
    """
    Loads a specific tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.

    Returns:
        List[Dict[str, Any]]: The configuration data as a list of dictionaries.
    """
    ...

def save_config(tool_name: str, config_name: str, config_data: Any) -> None:
    """
    Saves a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        config_data (Any): The configuration data to save.
    """
    ...

def delete_config(tool_name: str, config_name: str, local_mode: bool = False) -> None:
    """
    Deletes a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        local_mode (bool): Whether the configuration is in local mode.
                           Defaults to False.
    """
    ...

# --- Offline Access ---

def initialize_offline_access() -> None:
    """
    Creates and sets the offline access token for the user.

    NOTE: This method must be called outside of Script Runner before
    executing any API methods that require an offline access token, such
    as `script_run`.
    """
    ...

def offline_access_needed() -> bool:
    """
    Checks if the user needs to generate an offline access token.

    Returns:
        bool: True if an offline access token is needed for the user,
              False otherwise.
    """
    ...

def set_offline_access(offline_access_token: str) -> None:
    """
    Sets the offline access token in the backend.

    NOTE: You probably won't need to call this method directly, as it is
    automatically called by `initialize_offline_access()`.

    Args:
        offline_access_token (str): The Keycloak-generated refresh token
                                    with the `offline_access` openid scope.
    """
    ...
