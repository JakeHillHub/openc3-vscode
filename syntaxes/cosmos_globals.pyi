"""
This file is auto-generated by the openc3 extension to provide intellisense
NOTE: any modifications to this file will not persist between vscode plugin loads
"""

from typing import Any, overload, List, Dict, Tuple, Optional, IO, Iterator, Type

# --- Commanding ---

def cmd(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_no_range_check(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system, skipping the range check on parameters.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_no_hazardous_check(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system, skipping the hazardous command check.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_no_checks(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system, skipping both range and hazardous checks.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_raw(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system, bypassing parameter conversion.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of raw command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_raw_no_range_check(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system with no range check.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of raw command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_raw_no_hazardous_check(
    target: str, command: str, params: Dict[str, Any]
) -> None:
    """
    Sends a raw command through the COSMOS system with no hazardous check.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of raw command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

def cmd_raw_no_checks(target: str, command: str, params: Dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system with no checks.

    Args:
        target (str): The name of the target to send the command to.
        command (str): The name of the command to send.
        params (Dict[str, Any]): A dictionary of raw command parameters.

    Returns:
        None: This function does not return a value.
    """
    ...

# --- Command Building & Sending ---

def build_cmd(
    cmd_string: str, range_check: bool = True, raw: bool = False
) -> Dict[str, Any]:
    """
    Builds a command binary string to see the raw bytes for a given command.

    Args:
        cmd_string (str): The command string to build (e.g., 'INST PING').
        range_check (bool): Whether to perform a range check on the command parameters.
                            Defaults to True.
        raw (bool): Whether to build the command with raw values. Defaults to False.

    Returns:
        Dict[str, Any]: A dictionary containing the command's metadata and the raw byte string.
    """
    ...

def send_raw(interface_name: str, data: bytes) -> None:
    """
    Sends raw data on an interface.

    Args:
        interface_name (str): The name of the interface to send data on.
        data (bytes): The raw data to send.

    Returns:
        None: This function does not return a value.
    """
    ...

# --- Command State ---

@overload
def enable_cmd(cmd_string: str) -> None: ...
@overload
def enable_cmd(target_name: str, command_name: str) -> None: ...
def enable_cmd(*args: str) -> None:
    """
    Enables a disabled command.

    Args:
        *args: Either a single command string (e.g., 'INST PING') or
               the target name and command name as separate strings.

    Returns:
        None: This function does not return a value.
    """
    ...

@overload
def disable_cmd(cmd_string: str) -> None: ...
@overload
def disable_cmd(target_name: str, command_name: str) -> None: ...
def disable_cmd(*args: str) -> None:
    """
    Disables a command.

    Args:
        *args: Either a single command string (e.g., 'INST PING') or
               the target name and command name as separate strings.

    Returns:
        None: This function does not return a value.
    """
    ...

# --- Command Information ---

def get_all_cmds(target_name: str) -> List[Dict[str, Any]]:
    """
    Returns a list of dicts which fully describe the command packets for a target.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              describes a command packet for the target.
    """
    ...

def get_all_cmd_names(target_name: str) -> List[str]:
    """
    Returns a list of the command names for a particular target.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[str]: A list of command names.
    """
    ...

@overload
def get_cmd(cmd_string: str) -> Dict[str, Any]: ...
@overload
def get_cmd(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_cmd(*args: str) -> Dict[str, Any]:
    """
    Returns a dict which fully describes a command packet.

    Args:
        *args: Either a single command string (e.g., "INST PING") or the target name
               and packet name as separate strings.

    Returns:
        Dict[str, Any]: A dictionary that fully describes the command packet.
    """
    ...

@overload
def get_param(param_string: str) -> Dict[str, Any]: ...
@overload
def get_param(
    target_name: str, command_name: str, param_name: str
) -> Dict[str, Any]: ...
def get_param(*args: str) -> Dict[str, Any]:
    """
    Returns a dict of the given command parameter.

    Args:
        *args: Either a single parameter string (e.g., "INST PING.PARAM_A") or the target name,
               command name, and parameter name as separate strings.

    Returns:
        Dict[str, Any]: A dictionary describing the command parameter.
    """
    ...

@overload
def get_cmd_buffer(cmd_string: str) -> Dict[str, Any]: ...
@overload
def get_cmd_buffer(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_cmd_buffer(*args: str) -> Dict[str, Any]:
    """
    Returns a packet dict along with the raw packet buffer.

    Args:
        *args: Either a single command string or the target name and packet name.

    Returns:
        Dict[str, Any]: A dictionary containing the command packet along with its raw buffer.
    """
    ...

def get_cmd_hazardous(
    target_name: str, command_name: str, params: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Returns true/false indicating whether a particular command is flagged as hazardous.

    Args:
        target_name (str): The name of the target.
        command_name (str): The name of the command.
        params (Optional[Dict[str, Any]]): An optional dictionary of command parameters
                                            to check for hazardous conditions.

    Returns:
        bool: True if the command is hazardous, False otherwise.
    """
    ...

# --- Command Telemetry ---

def get_cmd_value(
    target_name: str,
    command_name: str,
    param_name: str,
    value_type: Optional[str] = None,
) -> Any:
    """
    Reads a value from the most recently sent command packet.

    Args:
        target_name (str): The name of the target.
        command_name (str): The name of the command.
        param_name (str): The name of the command parameter to retrieve.
        value_type (Optional[str]): The type of value to retrieve (e.g., 'RAW', 'CONVERTED').
                                     Defaults to the command's configured default.

    Returns:
        Any: The value of the specified command parameter.
    """
    ...

def get_cmd_time(
    target_name: Optional[str] = None, command_name: Optional[str] = None
) -> Tuple[str, str, Any]:
    """
    Returns the time of the most recent command sent.

    Args:
        target_name (Optional[str]): The name of the target.
        command_name (Optional[str]): The name of the command.

    Returns:
        Tuple[str, str, Any]: A tuple containing the target name, command name,
                              and the timestamp of the last sent command.
    """
    ...

@overload
def get_cmd_cnt(cmd_string: str) -> int: ...
@overload
def get_cmd_cnt(target_name: str, command_name: str) -> int: ...
def get_cmd_cnt(*args: Any) -> int:
    """
    Returns the number of times a specified command has been sent.

    Args:
        *args: Either a single command string (e.g., 'INST PING'), or
               the target name and command name as separate strings.

    Returns:
        int: The count of how many times the command has been sent.
    """
    ...

def get_cmd_cnts(commands: List[List[str]]) -> int:
    """
    Returns the number of times the specified commands have been sent.

    Args:
        commands (List[List[str]]): A list of command lists, where each inner
                                    list is [target_name, command_name].

    Returns:
        int: The sum of the send counts for all specified commands.
    """
    ...

# --- Critical Command Handling ---

def critical_cmd_status(uuid: str) -> str:
    """
    Returns the status of a critical command (APPROVED, REJECTED, or WAITING).

    Args:
        uuid (str): The unique identifier of the critical command.

    Returns:
        str: The status of the command: 'APPROVED', 'REJECTED', or 'WAITING'.
    """
    ...

def critical_cmd_approve(uuid: str) -> None:
    """
    Approves the critical command as the current user.

    Args:
        uuid (str): The unique identifier of the critical command.

    Returns:
        None: This function does not return a value.
    """
    ...

def critical_cmd_reject(uuid: str) -> None:
    """
    Rejects the critical command as the current user.

    Args:
        uuid (str): The unique identifier of the critical command.

    Returns:
        None: This function does not return a value.
    """
    ...

def critical_cmd_can_approve(uuid: str) -> bool:
    """
    Returns whether the current user can approve the critical command.

    Args:
        uuid (str): The unique identifier of the critical command.

    Returns:
        bool: True if the user can approve the command, False otherwise.
    """
    ...

# --- Command Queue Management ---

def queue_create(queue_name: str) -> None:
    """
    Creates a command queue, initially in the HOLD state.

    Args:
        queue_name (str): The name of the new queue to create.

    Returns:
        None: This function does not return a value.
    """
    ...

def queue_get(queue_name: str) -> Dict[str, Any]:
    """
    Gets information about a command queue, including its state.

    Args:
        queue_name (str): The name of the queue to retrieve information for.

    Returns:
        Dict[str, Any]: A dictionary containing information about the queue.
    """
    ...

def queue_all() -> List[Dict[str, Any]]:
    """
    Gets information about all command queues.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              contains information about a queue.
    """
    ...

def queue_list(queue_name: str) -> List[Dict[str, Any]]:
    """
    Lists all commands in the queue, including username, creation time, and the command itself.

    Args:
        queue_name (str): The name of the queue to list commands from.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a command in the queue.
    """
    ...

def queue_hold(queue_name: str) -> None:
    """
    Puts the specified queue into HOLD mode.

    Args:
        queue_name (str): The name of the queue to hold.

    Returns:
        None: This function does not return a value.
    """
    ...

def queue_release(queue_name: str) -> None:
    """
    Puts the specified queue into RELEASE mode.

    Args:
        queue_name (str): The name of the queue to release.

    Returns:
        None: This function does not return a value.
    """
    ...

def queue_disable(queue_name: str) -> None:
    """
    Puts the specified queue into DISABLE mode.

    Args:
        queue_name (str): The name of the queue to disable.

    Returns:
        None: This function does not return a value.
    """
    ...

def queue_exec(queue_name: str, index: Optional[int] = None) -> None:
    """
    Removes a command from the queue and executes it.
    If no index is given, the first command is executed.

    Args:
        queue_name (str): The name of the queue to execute from.
        index (Optional[int]): The index of the command to execute. Defaults to the
                               first command (index 0).

    Returns:
        None: This function does not return a value.
    """
    ...

def queue_delete(queue_name: str) -> None:
    """
    Deletes the specified queue and any commands that it holds.

    Args:
        queue_name (str): The name of the queue to delete.

    Returns:
        None: This function does not return a value.
    """
    ...

# --- Retrieving User Input ---

@overload
def ask(question: str) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool) -> Any: ...
@overload
def ask(question: str, blank_or_default: Any) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool, password: bool) -> Any: ...
def ask(*args: Any) -> Any:
    """
    Prompts the user for input and automatically converts the string to the
    appropriate data type.

    Args:
        question (str): The question to display to the user.
        blank_or_default (Any): A boolean or default value. If True, a blank
                                input is allowed. If a value is provided, it
                                will be used as the default.
        password (bool): If True, masks the input as a password.

    Returns:
        Any: The user's input, converted to the appropriate data type.
    """
    ...

@overload
def ask_string(question: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool) -> str: ...
@overload
def ask_string(question: str, blank_or_default: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool, password: bool) -> str: ...
def ask_string(*args: Any) -> str:
    """
    Prompts the user for input and always returns the input as a string.

    Args:
        question (str): The question to display to the user.
        blank_or_default (Any): A boolean or default value. If True, a blank
                                input is allowed. If a value is provided, it
                                will be used as the default.
        password (bool): If True, masks the input as a password.

    Returns:
        str: The user's input as a string.
    """
    ...

def message_box(message: str, *button_texts: str) -> str:
    """
    Creates a message box with arbitrary buttons and returns the text of the
    button clicked.

    Args:
        message (str): The message to display in the box.
        *button_texts (str): The text for each button.

    Returns:
        str: The text of the button the user clicked.
    """
    ...

def vertical_message_box(message: str, *button_texts: str) -> str:
    """
    Creates a vertical message box with arbitrary buttons and returns the text
    of the button clicked.

    Args:
        message (str): The message to display in the box.
        *button_texts (str): The text for each button.

    Returns:
        str: The text of the button the user clicked.
    """
    ...

def combo_box(message: str, *selection_texts: str) -> str:
    """
    Creates a combo box with arbitrary selections and returns the text of the
    selection clicked.

    Args:
        message (str): The message to display above the combo box.
        *selection_texts (str): The text for each selection in the combo box.

    Returns:
        str: The text of the selection the user chose.
    """
    ...

# --- File Operations ---

def get_target_file(file_path: str, original: bool = False) -> IO:
    """
    Returns a file handle to a file in the target directory.

    Args:
        file_path (str): The path to the file on the target.
        original (bool): If True, retrieves the original version of the file, ignoring
                         any patches. Defaults to False.

    Returns:
        IO: A file-like object for the requested file.
    """
    ...

def put_target_file(file_path: str, data: str | IO) -> None:
    """
    Writes a file to the target directory.

    Args:
        file_path (str): The path to the file on the target.
        data (str | IO): The data to write. Can be a string or a file-like object.
    """
    ...

def delete_target_file(file_path: str) -> None:
    """
    Deletes a file in the target directory.

    Args:
        file_path (str): The path to the file on the target.
    """
    ...

@overload
def open_file_dialog(
    title: str, message: Optional[str] = None, filter: Optional[str] = None
) -> IO: ...
def open_file_dialog(*args: str, **kwargs: str) -> IO:
    """
    Creates a file dialog box for the user to select a single file. The selected
    file handle is returned.

    Args:
        title (str): The title of the dialog box.
        message (Optional[str]): A message to display in the dialog box.
                                 Defaults to None.
        filter (Optional[str]): A filter for the file types to show (e.g., "*.txt").
                                Defaults to None.

    Returns:
        IO: A file-like object for the selected file.
    """
    ...

@overload
def open_files_dialog(
    title: str, message: Optional[str] = None, filter: Optional[str] = None
) -> List[IO]: ...
def open_files_dialog(*args: str, **kwargs: str) -> List[IO]:
    """
    Creates a file dialog box for the user to select multiple files. A list of
    the selected file handles is returned.

    Args:
        title (str): The title of the dialog box.
        message (Optional[str]): A message to display in the dialog box.
                                 Defaults to None.
        filter (Optional[str]): A filter for the file types to show (e.g., "*.txt").
                                Defaults to None.

    Returns:
        List[IO]: A list of file-like objects for the selected files.
    """
    ...

# --- Providing Information to the User ---

def prompt(message: str) -> None:
    """
    Displays a message to the user and waits for them to press an OK button.

    Args:
        message (str): The string message to display to the user.

    Returns:
        None: This function does not return a value.
    """
    ...

# --- Handling Telemetry ---

RAW: str = "RAW"
CONVERTED: str = "CONVERTED"
FORMATTED: str = "FORMATTED"
WITH_UNITS: str = "WITH_UNITS"

@overload
def check(
    telemetry_item: str,
    comparison: Optional[str] = None,
    type: str = CONVERTED,
) -> None: ...
def check(
    telemetry_item: str,
    comparison: Optional[str] = None,
    type: str = CONVERTED,
) -> None:
    """
    Performs a verification of a telemetry item.

    Args:
        telemetry_item (str): The name of the telemetry item to check.
        comparison (Optional[str]): A string comparison to perform (e.g., "== 5").
                                    If omitted, a simple existence check is performed.
        type (str): The type of value to use for the check. Defaults to CONVERTED.
    """
    ...

@overload
def check_raw(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_raw(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item in RAW form.

    Args:
        telemetry_item (str): The name of the telemetry item to check.
        comparison (Optional[str]): A string comparison to perform (e.g., "== 5").
                                    If omitted, a simple existence check is performed.
    """
    ...

@overload
def check_formatted(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_formatted(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item in FORMATTED form.

    Args:
        telemetry_item (str): The name of the telemetry item to check.
        comparison (Optional[str]): A string comparison to perform (e.g., "== 'OK'").
                                    If omitted, a simple existence check is performed.
    """
    ...

@overload
def check_with_units(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_with_units(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item with UNITS.

    Args:
        telemetry_item (str): The name of the telemetry item to check.
        comparison (Optional[str]): A string comparison to perform (e.g., "== '5 C'").
                                    If omitted, a simple existence check is performed.
    """
    ...

def check_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    type: str = CONVERTED,
) -> None:
    """
    Checks a converted telemetry item against an expected value with a tolerance.

    Args:
        telemetry_item (str): The name of the telemetry item.
        expected_value (float): The expected value.
        tolerance (float): The allowed tolerance.
        type (str): The type of value to use for the check. Defaults to CONVERTED.
    """
    ...

def check_expression(
    expression_to_evaluate: str,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
) -> None:
    """
    Evaluates an expression and pauses the script if it evaluates to false.

    Args:
        expression_to_evaluate (str): The expression to evaluate.
        globals (Optional[Dict]): A dictionary of global variables for the expression.
        locals (Optional[Dict]): A dictionary of local variables for the expression.
    """
    ...

@overload
def check_exception(method_name: str, method_params: Optional[str] = None) -> None: ...
@overload
def check_exception(method_name: str, **kwargs: Any) -> None: ...
def check_exception(*args: Any, **kwargs: Any) -> None:
    """
    Executes a method and expects an exception to be raised.

    Args:
        method_name (str): The name of the method to execute.
        method_params (Optional[str]): Parameters to pass to the method.
        **kwargs: Additional keyword arguments to pass to the method.
    """
    ...

@overload
def tlm(telemetry_item: str, type: str = CONVERTED) -> Any: ...
@overload
def tlm(
    target_name: str, packet_name: str, item_name: str, type: str = CONVERTED
) -> Any: ...
def tlm(*args: str, **kwargs: str) -> Any:
    """
    Reads the specified form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.
        type (str): The type of value to return (RAW, CONVERTED, FORMATTED, or WITH_UNITS).
                    Defaults to CONVERTED.

    Returns:
        Any: The value of the telemetry item in the specified form.
    """
    ...

@overload
def tlm_raw(telemetry_item: str) -> Any: ...
@overload
def tlm_raw(target_name: str, packet_name: str, item_name: str) -> Any: ...
def tlm_raw(*args: str) -> Any:
    """
    Reads the RAW form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        Any: The raw value of the telemetry item.
    """
    ...

@overload
def tlm_formatted(telemetry_item: str) -> str: ...
@overload
def tlm_formatted(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_formatted(*args: str) -> str:
    """
    Reads the FORMATTED form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        str: The formatted string value of the telemetry item.
    """
    ...

@overload
def tlm_with_units(telemetry_item: str) -> str: ...
@overload
def tlm_with_units(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_with_units(*args: str) -> str:
    """
    Reads the WITH_UNITS form of a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        str: The string value of the telemetry item including its units.
    """
    ...

@overload
def get_tlm_buffer(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm_buffer(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm_buffer(*args: str) -> Dict[str, Any]:
    """
    Returns a packet hash along with the raw packet buffer.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        Dict[str, Any]: A dictionary containing the packet data, including the raw buffer.
    """
    ...

@overload
def get_tlm_packet(
    telemetry_packet: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
@overload
def get_tlm_packet(
    target_name: str, packet_name: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
def get_tlm_packet(*args: str, **kwargs: str) -> List[Tuple[str, Any, str]]:
    """
    Returns the names, values, and limits states of all telemetry items in a specified packet.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        type (str): The type of value to return. Defaults to CONVERTED.

    Returns:
        List[Tuple[str, Any, str]]: A list of tuples, where each tuple contains
                                    (item_name, item_value, limits_state).
    """
    ...

def get_tlm_available(items: List[str]) -> List[str]:
    """
    Returns the actual items available based on the specified set of telemetry items.

    Args:
        items (List[str]): A list of telemetry item names to check for availability.

    Returns:
        List[str]: A list of the available telemetry item names.
    """
    ...

def get_tlm_values(
    items: List[str],
) -> Tuple[List[Any], List[str], List[Any], List[str]]:
    """
    Returns the values and current limits state for a specified set of telemetry items.

    Args:
        items (List[str]): A list of telemetry item names to retrieve values for.

    Returns:
        Tuple[List[Any], List[str], List[Any], List[str]]: A tuple containing
                                                        (values, limits_states, raw_values, times).
    """
    ...

def get_all_tlm(target_name: str) -> List[Dict[str, Any]]:
    """
    Returns an array of all target packet hashes.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a telemetry packet.
    """
    ...

def get_all_tlm_names(target_name: str) -> List[str]:
    """
    Returns an array of all target packet names.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[str]: A list of strings representing the packet names.
    """
    ...

def get_all_tlm_item_names(target_name: str) -> List[str]:
    """
    Returns all the item names for every packet in a target.

    Args:
        target_name (str): The name of the target.

    Returns:
        List[str]: A list of strings representing the item names.
    """
    ...

@overload
def get_tlm(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm(*args: str) -> Dict[str, Any]:
    """
    Returns a packet hash.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        Dict[str, Any]: A dictionary representing the telemetry packet.
    """
    ...

@overload
def get_item(telemetry_item: str) -> Dict[str, Any]: ...
@overload
def get_item(target_name: str, packet_name: str, item_name: str) -> Dict[str, Any]: ...
def get_item(*args: str) -> Dict[str, Any]:
    """
    Returns an item hash.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        Dict[str, Any]: A dictionary representing the telemetry item.
    """
    ...

@overload
def get_tlm_cnt(telemetry_packet: str) -> int: ...
@overload
def get_tlm_cnt(target_name: str, packet_name: str) -> int: ...
def get_tlm_cnt(*args: str) -> int:
    """
    Returns the number of times a specified telemetry packet has been received.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        int: The receive count for the packet.
    """
    ...

@overload
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None: ...
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None:
    """
    Sets a telemetry item value in the Command and Telemetry Server.

    Args:
        telemetry_item_with_value (str): The name of the telemetry item and its new value
                                        (e.g., "INST HEALTH_STATUS TEMP1 50").
        type (str): The type of value being set. Defaults to CONVERTED.
    """
    ...

@overload
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None: ...
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None:
    """
    Injects a packet into the system.

    Args:
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_hash (Optional[Dict]): A dictionary of item names and values to inject.
                                   If omitted, an empty packet is injected.
        type (str): The type of value being injected. Defaults to CONVERTED.
    """
    ...

@overload
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None: ...
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None:
    """
    Sets the converted value for a telemetry point and maintains it.

    Args:
        telemetry_item_with_value (str): The name of the telemetry item and its new value
                                        (e.g., "INST HEALTH_STATUS TEMP1 50").
        type (str): The override type (e.g., RAW, CONVERTED, or "ALL"). Defaults to "ALL".
    """
    ...

@overload
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None: ...
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None:
    """
    Clears the override of a telemetry point.

    Args:
        telemetry_item (str): The full name of the telemetry item to normalize (e.g., "INST HEALTH_STATUS TEMP1").
        type (str): The override type to normalize (e.g., RAW, CONVERTED, or "ALL"). Defaults to "ALL".
    """
    ...

def get_overrides() -> List[Dict[str, Any]]:
    """
    Returns a list of the currently overridden values.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents an overridden telemetry item.
    """
    ...

# --- Packet Data Subscriptions ---

def subscribe_packets(packets: List[List[str]]) -> int:
    """
    Allows the user to listen for one or more telemetry packets of data to arrive.
    A unique id is returned which is used to retrieve the data.

    Args:
        packets (List[List[str]]): A list of packets to subscribe to,
                                   with each packet as a list of [target_name, packet_name].

    Returns:
        int: A unique subscription ID used to retrieve the data.
    """
    ...

@overload
def get_packets(
    id: int, block: Optional[int] = None, count: int = 1000
) -> Tuple[int, List[Dict[str, Any]]]: ...
def get_packets(
    id: int, block: Optional[int] = None, count: int = 1000
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    Streams packet data from a previous subscription.

    Args:
        id (int): The subscription ID returned by subscribe_packets().
        block (Optional[int]): The block number to start retrieving data from.
                               If not provided, retrieves from the last block.
        count (int): The number of packets to retrieve. Defaults to 1000.

    Returns:
        Tuple[int, List[Dict[str, Any]]]: A tuple containing the next block number
                                          and a list of packet data dictionaries.
    """
    ...

@overload
def get_tlm_cnt(telemetry_packet: str) -> int: ...
@overload
def get_tlm_cnt(target_name: str, packet_name: str) -> int: ...
def get_tlm_cnt(*args: str) -> int:
    """
    Gets the receive count for a telemetry packet.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        int: The number of times the packet has been received.
    """
    ...

def get_tlm_cnts(packets: List[List[str]]) -> List[int]:
    """
    Gets the receive counts for an array of telemetry packets.

    Args:
        packets (List[List[str]]): A list of packets, with each packet as a list
                                   of [target_name, packet_name].

    Returns:
        List[int]: A list of integers representing the receive count for each packet.
    """
    ...

@overload
def get_packet_derived_items(telemetry_packet: str) -> List[str]: ...
@overload
def get_packet_derived_items(target_name: str, packet_name: str) -> List[str]: ...
def get_packet_derived_items(*args: str) -> List[str]:
    """
    Gets the list of derived telemetry items for a packet.

    Args:
        telemetry_packet (str): The full name of the telemetry packet (e.g., "INST HEALTH_STATUS").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.

    Returns:
        List[str]: A list of strings representing the names of the derived items.
    """
    ...

# --- Delays ---
DEFAULT_TLM_POLLING_RATE: float = 0.25
CONVERTED: str = "CONVERTED"

@overload
def wait() -> float: ...
@overload
def wait(time_in_seconds: float) -> float: ...
@overload
def wait(
    telemetry_item: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
    quiet: bool = True,
) -> bool: ...
def wait(*args: Any, **kwargs: Any) -> Any:
    """
    Pauses the script for a configurable amount of time or until a telemetry item meets given criteria.

    Args:
        time_in_seconds (float): The amount of time to wait in seconds.
        telemetry_item (str): The name of the telemetry item to wait on.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        type (str): The type of value to use (e.g., 'CONVERTED'). Defaults to 'CONVERTED'.
        quiet (bool): If True, suppresses output during the wait. Defaults to True.

    Returns:
        float: The time waited in seconds if only time is given.
        bool: True if the wait condition was met, False otherwise.
    """
    ...

def wait_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
    quiet: bool = True,
) -> bool:
    """
    Pauses the script until a telemetry item equals an expected value within a tolerance.

    Args:
        telemetry_item (str): The name of the telemetry item.
        expected_value (float): The value to wait for.
        tolerance (float): The allowed tolerance.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        type (str): The type of value to use (e.g., 'CONVERTED'). Defaults to 'CONVERTED'.
        quiet (bool): If True, suppresses output during the wait. Defaults to True.

    Returns:
        bool: True if the wait condition was met, False otherwise.
    """
    ...

def wait_expression(
    expression_to_eval: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
    quiet: bool = False,
) -> bool:
    """
    Pauses the script until an expression is evaluated to be true or a timeout occurs.

    Args:
        expression_to_eval (str): The expression to evaluate.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        globals (Optional[Dict]): A dictionary of global variables to use in the expression.
        locals (Optional[Dict]): A dictionary of local variables to use in the expression.
        quiet (bool): If True, suppresses output during the wait. Defaults to False.

    Returns:
        bool: True if the expression evaluated to True, False otherwise.
    """
    ...

def wait_packet(
    target_name: str,
    packet_name: str,
    num_packets: int,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    quiet: bool = True,
) -> bool:
    """
    Pauses the script until a certain number of packets have been received.

    Args:
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        num_packets (int): The number of packets to wait for.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll for new packets. Defaults to 0.25 seconds.
        quiet (bool): If True, suppresses output during the wait. Defaults to True.

    Returns:
        bool: True if the wait condition was met, False otherwise.
    """
    ...

def wait_check(
    telemetry_item: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
) -> float:
    """
    Pauses the script until a telemetry item meets given criteria or times out, stopping on timeout.

    Args:
        telemetry_item (str): The name of the telemetry item.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        type (str): The type of value to use (e.g., 'CONVERTED'). Defaults to 'CONVERTED'.

    Returns:
        float: The time waited in seconds.
    """
    ...

def wait_check_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
) -> float:
    """
    Pauses the script until a telemetry item equals an expected value within a tolerance, stopping on timeout.

    Args:
        telemetry_item (str): The name of the telemetry item.
        expected_value (float): The value to wait for.
        tolerance (float): The allowed tolerance.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        type (str): The type of value to use (e.g., 'CONVERTED'). Defaults to 'CONVERTED'.

    Returns:
        float: The time waited in seconds.
    """
    ...

def wait_check_expression(
    expression_to_eval: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
) -> float:
    """
    Pauses the script until an expression evaluates to true or times out, stopping on timeout.

    Args:
        expression_to_eval (str): The expression to evaluate.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll the telemetry item. Defaults to 0.25 seconds.
        globals (Optional[Dict]): A dictionary of global variables to use in the expression.
        locals (Optional[Dict]): A dictionary of local variables to use in the expression.

    Returns:
        float: The time waited in seconds.
    """
    ...

def wait_check_packet(
    target_name: str,
    packet_name: str,
    num_packets: int,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    quiet: bool = True,
) -> float:
    """
    Pauses the script until a certain number of packets have been received, stopping on timeout.

    Args:
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        num_packets (int): The number of packets to wait for.
        timeout (float): The maximum time to wait in seconds.
        polling_rate (float): The rate at which to poll for new packets. Defaults to 0.25 seconds.
        quiet (bool): If True, suppresses output during the wait. Defaults to True.

    Returns:
        float: The time waited in seconds.
    """
    ...

# --- Limits ---

@overload
def limits_enabled(telemetry_item: str) -> bool: ...
@overload
def limits_enabled(target_name: str, packet_name: str, item_name: str) -> bool: ...
def limits_enabled(*args: str) -> bool:
    """
    Returns true/false depending on whether limits are enabled for a telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        bool: True if limits are enabled, False otherwise.
    """
    ...

@overload
def enable_limits(telemetry_item: str) -> None: ...
@overload
def enable_limits(target_name: str, packet_name: str, item_name: str) -> None: ...
def enable_limits(*args: str) -> None:
    """
    Enables limits monitoring for the specified telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.
    """
    ...

@overload
def disable_limits(telemetry_item: str) -> None: ...
@overload
def disable_limits(target_name: str, packet_name: str, item_name: str) -> None: ...
def disable_limits(*args: str) -> None:
    """
    Disables limits monitoring for the specified telemetry item.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.
    """
    ...

def enable_limits_group(limits_group_name: str) -> None:
    """
    Enables limits monitoring on a set of telemetry items specified in a limits group.

    Args:
        limits_group_name (str): The name of the limits group to enable.
    """
    ...

def disable_limits_group(limits_group_name: str) -> None:
    """
    Disables limits monitoring on a set of telemetry items specified in a limits group.

    Args:
        limits_group_name (str): The name of the limits group to disable.
    """
    ...

def get_limits_groups() -> List[str]:
    """
    Returns the list of limits groups in the system.

    Returns:
        List[str]: A list of strings representing the limits group names.
    """
    ...

def set_limits_set(limits_set_name: str) -> None:
    """
    Sets the current limits set.

    Args:
        limits_set_name (str): The name of the limits set to activate.
    """
    ...

def get_limits_set() -> str:
    """
    Returns the name of the current limits set.

    Returns:
        str: The name of the active limits set.
    """
    ...

def get_limits_sets() -> List[str]:
    """
    Returns the list of limits sets in the system.

    Returns:
        List[str]: A list of strings representing the limits set names.
    """
    ...

@overload
def get_limits(telemetry_item: str) -> Dict[str, List[float]]: ...
@overload
def get_limits(
    target_name: str, packet_name: str, item_name: str
) -> Dict[str, List[float]]: ...
def get_limits(*args: str) -> Dict[str, List[float]]:
    """
    Returns a dictionary of all the limits settings for a telemetry point.

    Args:
        telemetry_item (str): The full name of the telemetry item (e.g., "INST HEALTH_STATUS TEMP1").
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.

    Returns:
        Dict[str, List[float]]: A dictionary containing the limits settings (e.g., 'red_high', 'yellow_low').
    """
    ...

@overload
def set_limits(
    target_name: str,
    packet_name: str,
    item_name: str,
    red_low: float,
    yellow_low: float,
    yellow_high: float,
    red_high: float,
    green_low: Optional[float] = None,
    green_high: Optional[float] = None,
    limits_set: Optional[str] = None,
    persistence: Optional[int] = None,
    enabled: Optional[bool] = None,
) -> None: ...
def set_limits(*args: Any, **kwargs: Any) -> None:
    """
    Sets limits settings for a telemetry point.

    Args:
        target_name (str): The name of the target.
        packet_name (str): The name of the packet.
        item_name (str): The name of the item.
        red_low (float): The lower red limit.
        yellow_low (float): The lower yellow limit.
        yellow_high (float): The upper yellow limit.
        red_high (float): The upper red limit.
        green_low (Optional[float]): The lower green limit.
        green_high (Optional[float]): The upper green limit.
        limits_set (Optional[str]): The name of the limits set to apply these limits to.
        persistence (Optional[int]): The number of samples an item must be out of limits to trigger an event.
        enabled (Optional[bool]): If True, enables the limits.
    """
    ...

def get_out_of_limits() -> List[Dict[str, str]]:
    """
    Returns a list of all items that are currently out of their defined limits.

    Returns:
        List[Dict[str, str]]: A list of dictionaries, where each dictionary contains
                              the 'target_name', 'packet_name', 'item_name', and 'limits_state'
                              of an out-of-limits item.
    """
    ...

def get_overall_limits_state(ignored_items: Optional[List[List[str]]] = None) -> str:
    """
    Returns the overall limits state for the COSMOS system.

    Args:
        ignored_items (Optional[List[List[str]]]): A list of items to ignore when calculating the state.

    Returns:
        str: The overall limits state (e.g., 'GREEN', 'YELLOW', 'RED').
    """
    ...

def get_limits_events(
    offset: Optional[str] = None, count: int = 100
) -> List[Tuple[str, Dict[str, Any]]]:
    """
    Returns limits events based on an offset returned from the last time it was called.

    Args:
        offset (Optional[str]): An offset to retrieve events from.
        count (int): The number of events to return. Defaults to 100.

    Returns:
        List[Tuple[str, Dict[str, Any]]]: A list of tuples, where each tuple contains an offset
                                          and a dictionary of event data.
    """
    ...

# --- Plugins / Packages ---

def plugin_list(default: bool = False) -> List[str]:
    """
    Returns all the installed plugins.

    Args:
        default (bool): If True, returns default plugins as well. Defaults to False.

    Returns:
        List[str]: A list of strings representing the installed plugin names.
    """
    ...

def plugin_get(plugin_name: str) -> Dict[str, Any]:
    """
    Returns information about an installed plugin.

    Args:
        plugin_name (str): The name of the plugin.

    Returns:
        Dict[str, Any]: A dictionary containing information about the plugin.
    """
    ...

def package_list() -> Dict[str, List[str]]:
    """
    Lists all the packages installed in COSMOS.

    Returns:
        Dict[str, List[str]]: A dictionary where keys are package types (e.g., 'gem', 'pip')
                              and values are lists of installed package names.
    """
    ...

# --- Targets ---

def get_target_names() -> List[str]:
    """
    Returns a list of the targets in the system.

    Returns:
        List[str]: A list of strings representing the target names.
    """
    ...

def get_target(target_name: str) -> Dict[str, Any]:
    """
    Returns a target hash containing all the information about the target.

    Args:
        target_name (str): The name of the target.

    Returns:
        Dict[str, Any]: A dictionary containing all information about the target.
    """
    ...

def get_target_interfaces() -> List[Tuple[str, str]]:
    """
    Returns the interfaces for all targets.

    Returns:
        List[Tuple[str, str]]: A list of tuples, where each tuple contains
                               the target name and its associated interface name.
    """
    ...

# --- Interfaces ---

def get_interface(interface_name: str) -> Dict[str, Any]:
    """
    Returns an interface status including the as-built interface and its current status.

    Args:
        interface_name (str): The name of the interface.

    Returns:
        Dict[str, Any]: A dictionary containing the interface's status and configuration.
    """
    ...

def get_interface_names() -> List[str]:
    """
    Returns a list of the interfaces in the system.

    Returns:
        List[str]: A list of strings representing the interface names.
    """
    ...

@overload
def connect_interface(interface_name: str) -> None:
    """
    Connects to targets associated with a COSMOS interface.
    """
    ...

@overload
def connect_interface(interface_name: str, *args: Any) -> None:
    """
    Connects to targets associated with a COSMOS interface with specific parameters.
    """
    ...

def connect_interface(*args: Any, **kwargs: Any) -> None: ...
def disconnect_interface(interface_name: str) -> None:
    """
    Disconnects from targets associated with a COSMOS interface.

    Args:
        interface_name (str): The name of the interface to disconnect.
    """
    ...

def start_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Starts logging of raw data on one or all interfaces.

    Args:
        interface_name (str): The name of the interface to start logging for.
                              Defaults to "ALL" to start logging for all interfaces.
    """
    ...

def stop_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Stops logging of raw data on one or all interfaces.

    Args:
        interface_name (str): The name of the interface to stop logging for.
                              Defaults to "ALL" to stop logging for all interfaces.
    """
    ...

def get_all_interface_info() -> (
    List[Tuple[str, str, int, int, int, int, int, int, int]]
):
    """
    Returns information about all interfaces.

    Returns:
        List[Tuple[str, str, int, int, int, int, int, int, int]]: A list of tuples, where each
        tuple contains the interface name, connection state, number of connected clients, transmit queue size,
        receive queue size, bytes transmitted, bytes received, command count, and telemetry count.
    """
    ...

def map_target_to_interface(
    target_name: str,
    interface_name: str,
    cmd_only: bool = False,
    tlm_only: bool = False,
    unmap_old: bool = True,
) -> None:
    """
    Maps a target to an interface, allowing the interface to process the target's commands and telemetry.

    Args:
        target_name (str): The name of the target.
        interface_name (str): The name of the interface.
        cmd_only (bool): If True, only map target commands to the interface. Defaults to False.
        tlm_only (bool): If True, only map target telemetry to the interface. Defaults to False.
        unmap_old (bool): If True, remove the target from all existing interfaces before mapping.
                          Defaults to True.
    """
    ...

def interface_cmd(
    interface_name: str, command_name: str, command_parameters: Optional[str] = None
) -> None:
    """
    Send a command directly to an interface.
    """
    ...

def interface_protocol_cmd(
    interface_name: str,
    command_name: str,
    command_parameters: Optional[str] = None,
    read_write: str = "READ_WRITE",
    index: int = -1,
) -> None:
    """
    Send a command directly to an interface protocol.
    """
    ...

# --- Routers ---

@overload
def connect_router(router_name: str) -> None: ...
@overload
def connect_router(router_name: str, *args: Any) -> None: ...
def connect_router(*args: Any, **kwargs: Any) -> None:
    """
    Connects a COSMOS router.

    Args:
        router_name (str): The name of the router.
        *args: Optional parameters used to initialize the router.
    """
    ...

def disconnect_router(router_name: str) -> None:
    """
    Disconnects a COSMOS router.

    Args:
        router_name (str): The name of the router.
    """
    ...

def get_router_names() -> List[str]:
    """
    Returns a list of the routers in the system.
    """
    ...

def get_router(router_name: str) -> Dict[str, Any]:
    """
    Returns a router status including the as-built router and its current status.

    Args:
        router_name (str): The name of the router.
    """
    ...

def get_all_router_info() -> List[Tuple[str, str, int, int, int, int, int, int, int]]:
    """
    Returns information about all routers. The return value is a list of tuples where each tuple
    contains the router name, connection state, number of connected clients, transmit queue size,
    receive queue size, bytes transmitted, bytes received, packets received, and packets sent.
    """
    ...

def start_raw_logging_router(router_name: str = "ALL") -> None:
    """
    Starts logging of raw data on one or all routers.

    Args:
        router_name (str, optional): Name of the router to start logging. Defaults to 'ALL'.
    """
    ...

def stop_raw_logging_router(router_name: str = "ALL") -> None:
    """
    Stops logging of raw data on one or all routers.

    Args:
        router_name (str, optional): Name of the router to stop logging. Defaults to 'ALL'.
    """
    ...

def router_cmd(
    router_name: str, command_name: str, command_parameters: Optional[str] = None
) -> None:
    """
    Send a command directly to a router.

    Args:
        router_name (str): The name of the router.
        command_name (str): The name of the command to send.
        command_parameters (str, optional): Any parameters to send with the command.
    """
    ...

def router_protocol_cmd(
    router_name: str,
    command_name: str,
    command_parameters: Optional[str] = None,
    read_write: str = "READ_WRITE",
    index: int = -1,
) -> None:
    """
    Send a command directly to a router protocol.

    Args:
        router_name (str): The name of the router.
        command_name (str): The name of the command to send.
        command_parameters (str, optional): Any parameters to send with the command.
        read_write (str, optional): 'READ', 'WRITE', or 'READ_WRITE'. Defaults to 'READ_WRITE'.
        index (int, optional): The protocol index in the stack. Defaults to -1 (all).
    """
    ...

# --- Tables ---

def table_create_binary(table_definition_file: str) -> Dict[str, str]:
    """
    Creates a table binary based on a table definition file.

    Args:
        table_definition_file (str): Path to the table definition file, e.g., 'INST/tables/config/ConfigTables_def.txt'

    Returns:
        Dict[str, str]: A dictionary containing the path to the created binary file, e.g., {'filename': '...'}
    """
    ...

def table_create_report(
    table_binary_file: str, table_definition_file: str, table_name: Optional[str] = None
) -> Dict[str, str]:
    """
    Creates a report from a table binary based on a table definition file.

    Args:
        table_binary_file (str): Path to the table binary file, e.g., 'INST/tables/bin/ConfigTables.bin'
        table_definition_file (str): Path to the table definition file, e.g., 'INST/tables/config/ConfigTables_def.txt'
        table_name (Optional[str]): The name of the specific table to create a report for. If not provided, a report for all tables in the file is generated.

    Returns:
        Dict[str, str]: A dictionary containing the filename and the contents of the generated report, e.g., {'filename': '...', 'contents': '...'}
    """
    ...

# --- Stashing Data ---

def stash_set(stash_key: str, stash_value: Any) -> None:
    """
    Sets a stash item.

    Args:
        stash_key (str): Name of the stash key to set.
        stash_value (Any): Value to set.
    """
    ...

def stash_get(stash_key: str) -> Any:
    """
    Returns the specified stash item.

    Args:
        stash_key (str): Name of the stash key to return.

    Returns:
        Any: The value of the stash item.
    """
    ...

def stash_all() -> Dict[str, Any]:
    """
    Returns all the stash items as a dictionary.

    Returns:
        Dict[str, Any]: A dictionary containing all stash items.
    """
    ...

def stash_keys() -> List[str]:
    """
    Returns all the stash keys.

    Returns:
        List[str]: A list of all stash keys.
    """
    ...

def stash_delete(stash_key: str) -> None:
    """
    Deletes a stash item.

    Args:
        stash_key (str): Name of the stash key to delete.
    """
    ...

# --- Telemetry Screens ---

def display_screen(
    target_name: str,
    screen_name: str,
    x_position: Optional[int] = None,
    y_position: Optional[int] = None,
) -> None:
    """
    Opens a telemetry screen at the specified position.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
        x_position (Optional[int]): X coordinate for the upper-left corner of the screen.
        y_position (Optional[int]): Y coordinate for the upper-left corner of the screen.
    """
    ...

def clear_screen(target_name: str, screen_name: str) -> None:
    """
    Closes an open telemetry screen.

    Args:
        target_name (str): Telemetry screen target name. For local screens, the target is 'LOCAL'.
        screen_name (str): Screen name within the specified target.
    """
    ...

def clear_all_screens() -> None:
    """
    Closes all open screens.
    """
    ...

def delete_screen(target_name: str, screen_name: str) -> None:
    """
    Deletes an existing Telemetry Viewer screen.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
    """
    ...

def get_screen_list() -> List[str]:
    """
    Returns a list of available telemetry screens.
    """
    ...

def get_screen_definition(target_name: str, screen_name: str) -> str:
    """
    Returns the text file contents of a telemetry screen definition.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.

    Returns:
        str: The entire screen definition as a string.
    """
    ...

def create_screen(target_name: str, screen_name: str, definition: str) -> None:
    """
    Allows you to create a screen directly from a script. This screen is saved to
    Telemetry Viewer for future use.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
        definition (str): The entire screen definition as a string.
    """
    ...

def local_screen(
    screen_name: str,
    definition: str,
    x_position: Optional[int] = None,
    y_position: Optional[int] = None,
) -> None:
    """
    Allows you to create a local screen directly from a script which is not
    permanently saved to the Telemetry Viewer screen list.

    Args:
        screen_name (str): Screen name.
        definition (str): The entire screen definition as a string.
        x_position (Optional[int]): X coordinate for the upper-left corner of the screen.
        y_position (Optional[int]): Y coordinate for the upper-left corner of the screen.
    """
    ...

# --- Script Runner Scripts ---

def start(procedure_filename: str) -> None:
    """
    Starts execution of another high-level test procedure.

    Args:
        procedure_filename (str): Name of the test procedure file.
    """
    ...

@overload
def goto(line_number: int) -> None: ...
@overload
def goto(filename: str, line_number: int) -> None: ...
def goto(arg1, arg2: Optional[int] = None) -> None:
    """
    Jumps to a specific line in either the current file or another file.

    Args:
        arg1 (Union[int, str]): The line number to jump to in the current file, or the filename to jump to.
        arg2 (Optional[int]): The line number in the specified file.
    """
    ...

def load_utility(utility_filename: str) -> None:
    """
    Reads in a script file that contains useful subroutines.

    Args:
        utility_filename (str): Name of the script file containing subroutines, including the full path.
    """
    ...

def script_list() -> List[str]:
    """
    Returns all the available files in COSMOS as a list.
    """
    ...

def script_create(script_name: str, script_contents: str) -> None:
    """
    Creates a new script with the given contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
        script_contents (str): Script contents as text.
    """
    ...

def script_body(script_name: str) -> str:
    """
    Returns the script contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_delete(script_name: str) -> None:
    """
    Deletes a script from COSMOS.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_run(
    script_name: str,
    disconnect: bool = False,
    environment: Optional[Dict[str, str]] = None,
    suite_runner: Optional[Dict[str, str]] = None,
) -> str:
    """
    Runs a script in Script Runner.

    Args:
        script_name (str): Full path name of the script starting with the target.
        disconnect (bool): Whether to run the script in Disconnect mode.
        environment (Optional[Dict[str, str]]): A dictionary of key/value items to set as script environment variables.
        suite_runner (Optional[Dict[str, str]]): A dictionary of suite runner options.

    Returns:
        str: The ID of the started script.
    """
    ...

def script_lock(script_name: str) -> None:
    """
    Locks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_unlock(script_name: str) -> None:
    """
    Unlocks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_syntax_check(script_name: str) -> Dict[str, Any]:
    """
    Performs a Ruby or Python syntax check on the given script.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        Dict[str, Any]: A dictionary containing the syntax check result.
    """
    ...

def script_instrumented(script_name: str) -> str:
    """
    Returns the instrumented script which allows COSMOS Script Runner to monitor
    the execution.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        str: The instrumented script contents.
    """
    ...

def script_delete_all_breakpoints() -> None:
    """
    Deletes all breakpoints associated with all scripts.
    """
    ...

def step_mode() -> None:
    """
    Places ScriptRunner into step mode.
    """
    ...

def run_mode() -> None:
    """
    Places ScriptRunner into run mode.
    """
    ...

def disconnect_script() -> None:
    """
    Puts scripting into disconnect mode.
    """
    ...

def running_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the currently running scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a running script.
    """
    ...

def script_get(script_id: str) -> Dict[str, Any]:
    """
    Gets information on the script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.

    Returns:
        Dict[str, Any]: A dictionary containing information about the script.
    """
    ...

def running_script_stop(script_id: str) -> None:
    """
    Stops the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_pause(script_id: str) -> None:
    """
    Pauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_retry(script_id: str) -> None:
    """
    Retries the current line of the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_go(script_id: str) -> None:
    """
    Unpauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int
) -> None: ...
@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int, end_line_number: int
) -> None: ...
def running_script_execute_while_paused(
    script_id: str,
    script_file_path: str,
    start_line_number: int,
    end_line_number: Optional[int] = None,
) -> None:
    """
    Performs a goto or executes a selection on a running script.

    Args:
        script_id (str): Script ID returned by script_run.
        script_file_path (str): Path to the script file.
        start_line_number (int): The line number to start at.
        end_line_number (Optional[int]): The line number to end at. If given, executes a selection.
    """
    ...

def running_script_step(script_id: str) -> None:
    """
    Steps the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_delete(script_id: str) -> None:
    """
    Force quits the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def completed_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the completed scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a completed script.
    """
    ...

# --- Script Runner Settings ---

def set_line_delay(delay: float) -> None:
    """
    Sets the line delay in Script Runner.

    Args:
        delay (float): The amount of time Script Runner will wait between
                       lines when executing a script, in seconds. Must be >= 0.0.
    """
    ...

def get_line_delay() -> float:
    """
    Gets the line delay that Script Runner is currently using.

    Returns:
        float: The current line delay in seconds.
    """
    ...

def set_max_output(characters: int) -> None:
    """
    Sets the maximum number of characters to display in Script Runner output.

    Args:
        characters (int): The maximum number of characters to output before truncating.
    """
    ...

def get_max_output() -> int:
    """
    Gets the maximum number of characters to display in Script Runner output.

    Returns:
        int: The maximum number of characters.
    """
    ...

def disable_instrumentation() -> Iterator[None]:
    """
    Disables instrumentation (line highlighting and exception catching) for a block of code.
    Use with a 'with' statement.

    Example:
        with disable_instrumentation():
            for x in range(1000):
                # This loop will not be instrumented
                pass
    """
    yield

# --- Base classes from the OpenC3 library ---

class Group:
    """
    Base class for defining a group of tests within a test suite.

    This class provides a structure for grouping related tests and
    can include optional `setup` and `teardown` methods that run
    before and after the tests in the group.
    """

    def setup(self) -> None:
        """
        Method that runs before any scripts in the group.
        """
        pass

    def teardown(self) -> None:
        """
        Method that runs after all scripts in the group.
        """
        pass

class Suite:
    """
    Base class for defining a test suite.

    A test suite is a collection of groups and individual scripts
    that can be executed together.
    """

    def __init__(self) -> None:
        pass

    def add_group(self, group_class: Type[Group]) -> None:
        """
        Adds all the methods of a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class to add.
        """
        pass

    def add_group_setup(self, group_class: Type[Group]) -> None:
        """
        Adds just the 'setup' method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the 'setup' method.
        """
        pass

    def add_group_teardown(self, group_class: Type[Group]) -> None:
        """
        Adds just the 'teardown' method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the 'teardown' method.
        """
        pass

    def add_script(self, group_class: Type[Group], method_name: str) -> None:
        """
        Adds a single method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the method.
            method_name (str): The name of the method to add.
        """
        pass

# --- Timelines ---
from datetime import datetime

def list_timelines() -> List[Dict[str, Any]]:
    """
    Returns a list of all timelines in the system.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a timeline.
    """
    ...

def create_timeline(name: str, color: Optional[str] = None) -> Dict[str, Any]:
    """
    Creates a new timeline in Calendar.

    Args:
        name (str): The name of the timeline.
        color (Optional[str]): The color of the timeline as a hex value (e.g., '#FF0000').
                               Defaults to a random color.

    Returns:
        Dict[str, Any]: A dictionary representing the created timeline.
    """
    ...

def get_timeline(name: str) -> Dict[str, Any]:
    """
    Gets information about an existing timeline.

    Args:
        name (str): The name of the timeline.

    Returns:
        Dict[str, Any]: A dictionary representing the timeline.
    """
    ...

def set_timeline_color(name: str, color: str) -> None:
    """
    Sets the displayed color for an existing timeline.

    Args:
        name (str): The name of the timeline.
        color (str): The color of the timeline as a hex value (e.g., '#4287f5').
    """
    ...

def delete_timeline(name: str, force: bool = False) -> None:
    """
    Deletes an existing timeline.

    Args:
        name (str): The name of the timeline.
        force (bool): If True, deletes the timeline even if it has activities.
                      Defaults to False.
    """
    ...

def create_timeline_activity(
    name: str, kind: str, start: datetime, stop: datetime, data: Dict[str, Any] = {}
) -> Dict[str, Any]:
    """
    Creates an activity on an existing timeline.

    Args:
        name (str): The name of the timeline.
        kind (str): The type of the activity. Must be one of 'COMMAND', 'SCRIPT', or 'RESERVE'.
        start (datetime): The start time of the activity.
        stop (datetime): The stop time of the activity.
        data (Dict[str, Any]): A dictionary of data for COMMAND or SCRIPT activities.
                               Defaults to an empty dictionary.

    Returns:
        Dict[str, Any]: A dictionary representing the created activity.
    """
    ...

def get_timeline_activity(name: str, start: datetime, uuid: str) -> Dict[str, Any]:
    """
    Gets an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.

    Returns:
        Dict[str, Any]: A dictionary representing the activity.
    """
    ...

def get_timeline_activities(
    name: str,
    start: Optional[datetime] = None,
    stop: Optional[datetime] = None,
    limit: Optional[int] = None,
) -> List[Dict[str, Any]]:
    """
    Gets a range of timeline activities.

    Args:
        name (str): The name of the timeline.
        start (Optional[datetime]): The start time of the activities. Defaults to 7 days ago.
        stop (Optional[datetime]): The stop time of the activities. Defaults to 7 days from now.
        limit (Optional[int]): The maximum number of activities to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary represents an activity.
    """
    ...

def delete_timeline_activity(name: str, start: datetime, uuid: str) -> None:
    """
    Deletes an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.
    """
    ...

# --- Metadata ---

def metadata_all(limit: int = 100) -> List[Dict[str, Any]]:
    """
    Returns all the metadata that was previously set.

    Args:
        limit (int): The maximum number of metadata items to return. Defaults to 100.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_get(start: str) -> List[Dict[str, Any]]:
    """
    Returns metadata that was previously set, starting from a specified time.

    Args:
        start (str): Time at which to retrieve metadata as an integer or string
                     representing seconds from epoch.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_set(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Sets metadata which appears in the Calendar tool.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to store as metadata.
        start (Optional[datetime]): Time at which to store the metadata. Defaults to now.
        color (Optional[str]): Color to display the metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_update(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Updates metadata that was previously set.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to update as metadata.
        start (Optional[datetime]): Time at which to update metadata. Defaults to the
                                    latest metadata item.
        color (Optional[str]): Color to display metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_input() -> Dict[str, Any]:
    """
    Prompts the user to set existing metadata values or create a new one.

    Returns:
        Dict[str, Any]: A dictionary containing the metadata entered by the user.
    """
    ...

# --- Settings ---

def list_settings() -> List[str]:
    """
    Returns all the current COSMOS setting names.

    Returns:
        List[str]: A list of strings representing the names of the available settings.
    """
    ...

def get_all_settings() -> Dict[str, Any]:
    """
    Returns all the current COSMOS settings along with their values.

    Returns:
        Dict[str, Any]: A dictionary where keys are setting names and values are
                        dictionaries containing the setting data.
    """
    ...

def get_setting(setting_name: str) -> Optional[Any]:
    """
    Returns the value of a specific COSMOS setting.

    Args:
        setting_name (str): The name of the setting.

    Returns:
        Optional[Any]: The value of the setting, or None if the setting does not exist.
    """
    ...

def get_settings(*setting_names: str) -> List[Optional[Any]]:
    """
    Returns the data from one or more COSMOS settings.

    Args:
        *setting_names (str): The names of the settings to return.

    Returns:
        List[Optional[Any]]: A list containing the values of the requested settings.
                             The order matches the input order.
    """
    ...

def set_setting(setting_name: str, setting_value: Any) -> None:
    """
    Sets the value for a given setting.

    NOTE: This API is only accessible externally (not within Script Runner)
          and requires the admin password.

    Args:
        setting_name (str): The name of the setting to change.
        setting_value (Any): The new value for the setting.
    """
    ...

# --- Configuration ---

def config_tool_names() -> List[str]:
    """
    Returns a list of all available configuration tool names.

    Returns:
        List[str]: A list of strings representing the tool names.
    """
    ...

def list_configs(tool_name: str) -> List[str]:
    """
    Lists all saved configuration names for a given tool.

    Args:
        tool_name (str): The name of the tool.

    Returns:
        List[str]: A list of strings representing the configuration names.
    """
    ...

def load_config(tool_name: str, config_name: str) -> List[Dict[str, Any]]:
    """
    Loads a specific tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.

    Returns:
        List[Dict[str, Any]]: The configuration data as a list of dictionaries.
    """
    ...

def save_config(tool_name: str, config_name: str, config_data: Any) -> None:
    """
    Saves a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        config_data (Any): The configuration data to save.
    """
    ...

def delete_config(tool_name: str, config_name: str, local_mode: bool = False) -> None:
    """
    Deletes a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        local_mode (bool): Whether the configuration is in local mode.
                           Defaults to False.
    """
    ...

# --- Offline Access ---

def initialize_offline_access() -> None:
    """
    Creates and sets the offline access token for the user.

    NOTE: This method must be called outside of Script Runner before
    executing any API methods that require an offline access token, such
    as `script_run`.
    """
    ...

def offline_access_needed() -> bool:
    """
    Checks if the user needs to generate an offline access token.

    Returns:
        bool: True if an offline access token is needed for the user,
              False otherwise.
    """
    ...

def set_offline_access(offline_access_token: str) -> None:
    """
    Sets the offline access token in the backend.

    NOTE: You probably won't need to call this method directly, as it is
    automatically called by `initialize_offline_access()`.

    Args:
        offline_access_token (str): The Keycloak-generated refresh token
                                    with the `offline_access` openid scope.
    """
    ...

# --- Autonomic Groups ---

def autonomic_group_list(scope: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Returns a list of all autonomic groups.

    Args:
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents an autonomic group.
    """
    ...

def autonomic_group_create(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Creates a new autonomic group.

    Args:
        name (str): The name of the group to create.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created group.
    """
    ...

def autonomic_group_show(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Shows details about a specific autonomic group.

    Args:
        name (str): The name of the group.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the group.
    """
    ...

def autonomic_group_destroy(name: str, scope: Optional[str] = None) -> None:
    """
    Destroys an autonomic group.

    Args:
        name (str): The name of the group to destroy.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

# --- Autonomic Triggers ---

def autonomic_trigger_list(
    group: str = "DEFAULT", scope: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Returns a list of triggers in a specific group.

    Args:
        group (str): The group to list triggers from. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a trigger.
    """
    ...

def autonomic_trigger_create(
    left: Dict[str, Any],
    operator: str,
    right: Dict[str, Any],
    group: str = "DEFAULT",
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Creates a new trigger with the specified condition.

    Args:
        left (Dict[str, Any]): The left side of the trigger condition.
        operator (str): The comparison operator (e.g., '>', '<', '==').
        right (Dict[str, Any]): The right side of the trigger condition.
        group (str): The group to create the trigger in. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created trigger.
    """
    ...

def autonomic_trigger_show(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> Dict[str, Any]:
    """
    Shows details about a specific trigger.

    Args:
        name (str): The name of the trigger.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the trigger.
    """
    ...

def autonomic_trigger_enable(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Enables a trigger.

    Args:
        name (str): The name of the trigger to enable.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_trigger_disable(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Disables a trigger.

    Args:
        name (str): The name of the trigger to disable.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_trigger_update(
    name: str,
    group: str = "DEFAULT",
    left: Optional[Dict[str, Any]] = None,
    operator: Optional[str] = None,
    right: Optional[Dict[str, Any]] = None,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Updates an existing trigger with new parameters.

    Args:
        name (str): The name of the trigger to update.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        left (Dict[str, Any], optional): The new left side of the condition.
        operator (str, optional): The new comparison operator.
        right (Dict[str, Any], optional): The new right side of the condition.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the updated trigger.
    """
    ...

def autonomic_trigger_destroy(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Destroys a trigger.

    Args:
        name (str): The name of the trigger to destroy.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

# --- Autonomic Reactions ---

def autonomic_reaction_list(scope: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Returns a list of all reactions.

    Args:
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a reaction.
    """
    ...

def autonomic_reaction_create(
    triggers: List[Dict[str, str]],
    actions: List[Dict[str, str]],
    trigger_level: str = "EDGE",
    snooze: int = 0,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Creates a new reaction that executes actions when triggers are activated.

    Args:
        triggers (List[Dict[str, str]]): A list of trigger names that activate this reaction.
        actions (List[Dict[str, str]]): A list of actions to perform when triggered.
        trigger_level (str): The trigger level ('EDGE' or 'LEVEL'). Defaults to 'EDGE'.
        snooze (int): The snooze time in seconds between activations. Defaults to 0.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created reaction.
    """
    ...

def autonomic_reaction_show(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Shows details about a specific reaction.

    Args:
        name (str): The name of the reaction.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the reaction.
    """
    ...

def autonomic_reaction_enable(name: str, scope: Optional[str] = None) -> None:
    """
    Enables a reaction.

    Args:
        name (str): The name of the reaction to enable.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_disable(name: str, scope: Optional[str] = None) -> None:
    """
    Disables a reaction.

    Args:
        name (str): The name of the reaction to disable.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_execute(name: str, scope: Optional[str] = None) -> None:
    """
    Manually executes a reaction's actions.

    Args:
        name (str): The name of the reaction to execute.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_update(
    name: str,
    triggers: Optional[List[Dict[str, str]]] = None,
    actions: Optional[List[Dict[str, str]]] = None,
    trigger_level: Optional[str] = None,
    snooze: Optional[int] = None,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Updates an existing reaction with new parameters.

    Args:
        name (str): The name of the reaction to update.
        triggers (List[Dict[str, str]], optional): New list of trigger names.
        actions (List[Dict[str, str]], optional): New list of actions.
        trigger_level (str, optional): New trigger level.
        snooze (int, optional): New snooze time in seconds.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the updated reaction.
    """
    ...

def autonomic_reaction_destroy(name: str, scope: Optional[str] = None) -> None:
    """
    Destroys a reaction.

    Args:
        name (str): The name of the reaction to destroy.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...
