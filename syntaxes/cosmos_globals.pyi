"""
This file is auto-generated by the openc3 extension to provide intellisense
NOTE: any modifications to this file will not persist between vscode plugin loads
"""

from typing import Any, overload, List, Dict, Tuple, Optional, IO, Iterator, Type

# --- Commanding ---

def cmd(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system.
    """
    ...

def cmd_no_range_check(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system with no range check.
    """
    ...

def cmd_no_hazardous_check(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system with no hazardous check.
    """
    ...

def cmd_no_checks(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a command through the COSMOS system with no checks.
    """
    ...

def cmd_raw(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system.
    """
    ...

def cmd_raw_no_range_check(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system with no range check.
    """
    ...

def cmd_raw_no_hazardous_check(
    target: str, command: str, params: dict[str, Any]
) -> None:
    """
    Sends a raw command through the COSMOS system with no hazardous check.
    """
    ...

def cmd_raw_no_checks(target: str, command: str, params: dict[str, Any]) -> None:
    """
    Sends a raw command through the COSMOS system with no checks.
    """
    ...

# --- Command Building & Sending ---

def build_cmd(
    cmd_string: str, range_check: bool = True, raw: bool = False
) -> Dict[str, Any]:
    """
    Builds a command binary string to see the raw bytes for a given command.
    """
    ...

def send_raw(interface_name: str, data: bytes) -> None:
    """
    Sends raw data on an interface.
    """
    ...

# --- Command State ---

@overload
def enable_cmd(cmd_string: str) -> None: ...
@overload
def enable_cmd(target_name: str, command_name: str) -> None: ...
def enable_cmd(*args) -> None:
    """
    Enables a disabled command.
    """
    ...

@overload
def disable_cmd(cmd_string: str) -> None: ...
@overload
def disable_cmd(target_name: str, command_name: str) -> None: ...
def disable_cmd(*args) -> None:
    """
    Disables a command.
    """
    ...

# --- Command Information ---

def get_all_cmds(target_name: str) -> List[Dict[str, Any]]:
    """
    Returns a list of dicts which fully describe the command packets for a target.
    """
    ...

def get_all_cmd_names(target_name: str) -> List[str]:
    """
    Returns a list of the command names for a particular target.
    """
    ...

@overload
def get_cmd(cmd_string: str) -> Dict[str, Any]: ...
@overload
def get_cmd(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_cmd(*args) -> Dict[str, Any]:
    """
    Returns a dict which fully describes a command packet.
    """
    ...

@overload
def get_param(param_string: str) -> Dict[str, Any]: ...
@overload
def get_param(
    target_name: str, command_name: str, param_name: str
) -> Dict[str, Any]: ...
def get_param(*args) -> Dict[str, Any]:
    """
    Returns a dict of the given command parameter.
    """
    ...

@overload
def get_cmd_buffer(cmd_string: str) -> Dict[str, Any]: ...
@overload
def get_cmd_buffer(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_cmd_buffer(*args) -> Dict[str, Any]:
    """
    Returns a packet dict along with the raw packet buffer.
    """
    ...

def get_cmd_hazardous(
    target_name: str, command_name: str, params: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Returns true/false indicating whether a particular command is flagged as hazardous.
    """
    ...

# --- Command Telemetry ---

def get_cmd_value(
    target_name: str,
    command_name: str,
    param_name: str,
    value_type: Optional[str] = None,
) -> Any:
    """
    Reads a value from the most recently sent command packet.
    """
    ...

def get_cmd_time(
    target_name: Optional[str] = None, command_name: Optional[str] = None
) -> Tuple[str, str, Any]:
    """
    Returns the time of the most recent command sent.
    """
    ...

@overload
def get_cmd_cnt(cmd_string: str) -> int: ...
@overload
def get_cmd_cnt(target_name: str, command_name: str) -> int: ...
def get_cmd_cnt(*args) -> int:
    """
    Returns the number of times a specified command has been sent.
    """
    ...

def get_cmd_cnts(commands: List[List[str]]) -> int:
    """
    Returns the number of times the specified commands have been sent.
    """
    ...

# --- Critical Command Handling ---

def critical_cmd_status(uuid: str) -> str:
    """
    Returns the status of a critical command (APPROVED, REJECTED, or WAITING).
    """
    ...

def critical_cmd_approve(uuid: str) -> None:
    """
    Approves the critical command as the current user.
    """
    ...

def critical_cmd_reject(uuid: str) -> None:
    """
    Rejects the critical command as the current user.
    """
    ...

def critical_cmd_can_approve(uuid: str) -> bool:
    """
    Returns whether the current user can approve the critical command.
    """
    ...

# --- Command Queue Management ---

def queue_create(queue_name: str) -> None:
    """
    Creates a command queue, initially in the HOLD state.
    """
    ...

def queue_get(queue_name: str) -> Dict[str, Any]:
    """
    Gets information about a command queue, including its state.
    """
    ...

def queue_all() -> List[Dict[str, Any]]:
    """
    Gets information about all command queues.
    """
    ...

def queue_list(queue_name: str) -> List[Dict[str, Any]]:
    """

    Lists all commands in the queue, including username, creation time, and the command itself.
    """
    ...

def queue_hold(queue_name: str) -> None:
    """
    Puts the specified queue into HOLD mode.
    """
    ...

def queue_release(queue_name: str) -> None:
    """
    Puts the specified queue into RELEASE mode.
    """
    ...

def queue_disable(queue_name: str) -> None:
    """
    Puts the specified queue into DISABLE mode.
    """
    ...

def queue_exec(queue_name: str, index: Optional[int] = None) -> None:
    """
    Removes a command from the queue and executes it.
    If no index is given, the first command is executed.
    """
    ...

def queue_delete(queue_name: str) -> None:
    """
    Deletes the specified queue and any commands that it holds.
    """
    ...

# --- Retrieving User Input ---

@overload
def ask(question: str) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool) -> Any: ...
@overload
def ask(question: str, blank_or_default: Any) -> Any: ...
@overload
def ask(question: str, blank_or_default: bool, password: bool) -> Any: ...
def ask(*args) -> Any:
    """
    Prompts the user for input and automatically converts the string to the
    appropriate data type.
    """
    ...

@overload
def ask_string(question: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool) -> str: ...
@overload
def ask_string(question: str, blank_or_default: str) -> str: ...
@overload
def ask_string(question: str, blank_or_default: bool, password: bool) -> str: ...
def ask_string(*args) -> str:
    """
    Prompts the user for input and always returns the input as a string.
    """
    ...

def message_box(message: str, *button_texts: str) -> str:
    """
    Creates a message box with arbitrary buttons and returns the text of the
    button clicked.
    """
    ...

def vertical_message_box(message: str, *button_texts: str) -> str:
    """
    Creates a vertical message box with arbitrary buttons and returns the text
    of the button clicked.
    """
    ...

def combo_box(message: str, *selection_texts: str) -> str:
    """
    Creates a combo box with arbitrary selections and returns the text of the
    selection clicked.
    """
    ...

# --- File Operations ---

def get_target_file(file_path: str, original: bool = False) -> IO:
    """
    Returns a file handle to a file in the target directory.
    """
    ...

def put_target_file(file_path: str, data: str | IO) -> None:
    """
    Writes a file to the target directory.
    """
    ...

def delete_target_file(file_path: str) -> None:
    """
    Deletes a file in the target directory.
    """
    ...

@overload
def open_file_dialog(
    title: str, message: Optional[str] = None, filter: Optional[str] = None
) -> IO: ...
def open_file_dialog(*args, **kwargs) -> IO:
    """
    Creates a file dialog box for the user to select a single file. The selected
    file handle is returned.
    """
    ...

@overload
def open_files_dialog(
    title: str, message: Optional[str] = None, filter: Optional[str] = None
) -> List[IO]: ...
def open_files_dialog(*args, **kwargs) -> List[IO]:
    """
    Creates a file dialog box for the user to select multiple files. A list of
    the selected file handles is returned.
    """
    ...

# --- Providing Information to the User ---

def prompt(message: str) -> None:
    """
    Displays a message to the user and waits for them to press an OK button.
    """
    ...

# --- Handling Telemetry ---
RAW: str = "RAW"
CONVERTED: str = "CONVERTED"
FORMATTED: str = "FORMATTED"
WITH_UNITS: str = "WITH_UNITS"

@overload
def check(
    telemetry_item: str,
    comparison: Optional[str] = None,
    type: str = CONVERTED,
) -> None: ...
def check(
    telemetry_item: str,
    comparison: Optional[str] = None,
    type: str = CONVERTED,
) -> None:
    """
    Performs a verification of a telemetry item.
    """
    ...

@overload
def check_raw(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_raw(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item in RAW form.
    """
    ...

@overload
def check_formatted(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_formatted(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item in FORMATTED form.
    """
    ...

@overload
def check_with_units(telemetry_item: str, comparison: Optional[str] = None) -> None: ...
def check_with_units(telemetry_item: str, comparison: Optional[str] = None) -> None:
    """
    Performs a verification of a telemetry item with UNITS.
    """
    ...

def check_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    type: str = CONVERTED,
) -> None:
    """
    Checks a converted telemetry item against an expected value with a tolerance.
    """
    ...

def check_expression(
    expression_to_evaluate: str,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
) -> None:
    """
    Evaluates an expression and pauses the script if it evaluates to false.
    """
    ...

@overload
def check_exception(method_name: str, method_params: Optional[str] = None) -> None: ...
@overload
def check_exception(method_name: str, **kwargs: Any) -> None: ...
def check_exception(*args, **kwargs) -> None:
    """
    Executes a method and expects an exception to be raised.
    """
    ...

@overload
def tlm(telemetry_item: str, type: str = CONVERTED) -> Any: ...
@overload
def tlm(
    target_name: str, packet_name: str, item_name: str, type: str = CONVERTED
) -> Any: ...
def tlm(*args, **kwargs) -> Any:
    """
    Reads the specified form of a telemetry item.
    """
    ...

@overload
def tlm_raw(telemetry_item: str) -> Any: ...
@overload
def tlm_raw(target_name: str, packet_name: str, item_name: str) -> Any: ...
def tlm_raw(*args) -> Any:
    """
    Reads the RAW form of a telemetry item.
    """
    ...

@overload
def tlm_formatted(telemetry_item: str) -> str: ...
@overload
def tlm_formatted(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_formatted(*args) -> str:
    """
    Reads the FORMATTED form of a telemetry item.
    """
    ...

@overload
def tlm_with_units(telemetry_item: str) -> str: ...
@overload
def tlm_with_units(target_name: str, packet_name: str, item_name: str) -> str: ...
def tlm_with_units(*args) -> str:
    """
    Reads the WITH_UNITS form of a telemetry item.
    """
    ...

@overload
def get_tlm_buffer(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm_buffer(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm_buffer(*args) -> Dict[str, Any]:
    """
    Returns a packet hash along with the raw packet buffer.
    """
    ...

@overload
def get_tlm_packet(
    telemetry_packet: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
@overload
def get_tlm_packet(
    target_name: str, packet_name: str, type: str = CONVERTED
) -> List[Tuple[str, Any, str]]: ...
def get_tlm_packet(*args, **kwargs) -> List[Tuple[str, Any, str]]:
    """
    Returns the names, values, and limits states of all telemetry items in a specified packet.
    """
    ...

def get_tlm_available(items: List[str]) -> List[str]:
    """
    Returns the actual items available based on the specified set of telemetry items.
    """
    ...

def get_tlm_values(
    items: List[str],
) -> Tuple[List[Any], List[str], List[Any], List[str]]:
    """
    Returns the values and current limits state for a specified set of telemetry items.
    """
    ...

def get_all_tlm(target_name: str) -> List[Dict[str, Any]]:
    """
    Returns an array of all target packet hashes.
    """
    ...

def get_all_tlm_names(target_name: str) -> List[str]:
    """
    Returns an array of all target packet names.
    """
    ...

def get_all_tlm_item_names(target_name: str) -> List[str]:
    """
    Returns all the item names for every packet in a target.
    """
    ...

@overload
def get_tlm(telemetry_packet: str) -> Dict[str, Any]: ...
@overload
def get_tlm(target_name: str, packet_name: str) -> Dict[str, Any]: ...
def get_tlm(*args) -> Dict[str, Any]:
    """
    Returns a packet hash.
    """
    ...

@overload
def get_item(telemetry_item: str) -> Dict[str, Any]: ...
@overload
def get_item(target_name: str, packet_name: str, item_name: str) -> Dict[str, Any]: ...
def get_item(*args) -> Dict[str, Any]:
    """
    Returns an item hash.
    """
    ...

@overload
def get_tlm_cnt(telemetry_packet: str) -> int: ...
@overload
def get_tlm_cnt(target_name: str, packet_name: str) -> int: ...
def get_tlm_cnt(*args) -> int:
    """
    Returns the number of times a specified telemetry packet has been received.
    """
    ...

@overload
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None: ...
def set_tlm(telemetry_item_with_value: str, type: str = CONVERTED) -> None:
    """
    Sets a telemetry item value in the Command and Telemetry Server.
    """
    ...

@overload
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None: ...
def inject_tlm(
    target_name: str,
    packet_name: str,
    item_hash: Optional[Dict] = None,
    type: str = CONVERTED,
) -> None:
    """
    Injects a packet into the system.
    """
    ...

@overload
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None: ...
def override_tlm(telemetry_item_with_value: str, type: str = "ALL") -> None:
    """
    Sets the converted value for a telemetry point and maintains it.
    """
    ...

@overload
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None: ...
def normalize_tlm(telemetry_item: str, type: str = "ALL") -> None:
    """
    Clears the override of a telemetry point.
    """
    ...

def get_overrides() -> List[Dict[str, Any]]:
    """
    Returns an array of the currently overridden values.
    """
    ...

# --- Packet Data Subscriptions ---

def subscribe_packets(packets: List[List[str]]) -> int:
    """
    Allows the user to listen for one or more telemetry packets of data to arrive.
    A unique id is returned which is used to retrieve the data.
    """
    ...

@overload
def get_packets(
    id: int, block: Optional[int] = None, count: int = 1000
) -> Tuple[int, List[Dict[str, Any]]]: ...
def get_packets(
    id: int, block: Optional[int] = None, count: int = 1000
) -> Tuple[int, List[Dict[str, Any]]]:
    """
    Streams packet data from a previous subscription.
    """
    ...

@overload
def get_tlm_cnt(telemetry_packet: str) -> int: ...
@overload
def get_tlm_cnt(target_name: str, packet_name: str) -> int: ...
def get_tlm_cnt(*args) -> int:
    """
    Get the receive count for a telemetry packet.
    """
    ...

def get_tlm_cnts(packets: List[List[str]]) -> List[int]:
    """
    Get the receive counts for an array of telemetry packets.
    """
    ...

@overload
def get_packet_derived_items(telemetry_packet: str) -> List[str]: ...
@overload
def get_packet_derived_items(target_name: str, packet_name: str) -> List[str]: ...
def get_packet_derived_items(*args) -> List[str]:
    """
    Get the list of derived telemetry items for a packet.
    """
    ...

# --- Delays ---
DEFAULT_TLM_POLLING_RATE: float = 0.25

@overload
def wait() -> float: ...
@overload
def wait(time_in_seconds: float) -> float: ...
@overload
def wait(
    telemetry_item: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
    quiet: bool = True,
) -> bool: ...
def wait(*args, **kwargs) -> Any:
    """
    Pauses the script for a configurable amount of time or until a telemetry item meets given criteria.
    """
    ...

def wait_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
    quiet: bool = True,
) -> bool:
    """
    Pauses the script until a telemetry item equals an expected value within a tolerance.
    """
    ...

def wait_expression(
    expression_to_eval: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
    quiet: bool = False,
) -> bool:
    """
    Pauses the script until an expression is evaluated to be true or a timeout occurs.
    """
    ...

def wait_packet(
    target_name: str,
    packet_name: str,
    num_packets: int,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    quiet: bool = True,
) -> bool:
    """
    Pauses the script until a certain number of packets have been received.
    """
    ...

def wait_check(
    telemetry_item: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
) -> float:
    """
    Pauses the script until a telemetry item meets given criteria or times out, stopping on timeout.
    """
    ...

def wait_check_tolerance(
    telemetry_item: str,
    expected_value: float,
    tolerance: float,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    type: str = CONVERTED,
) -> float:
    """
    Pauses the script until a telemetry item equals an expected value within a tolerance, stopping on timeout.
    """
    ...

def wait_check_expression(
    expression_to_eval: str,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    globals: Optional[Dict] = None,
    locals: Optional[Dict] = None,
) -> float:
    """
    Pauses the script until an expression evaluates to true or times out, stopping on timeout.
    """
    ...

def wait_check_packet(
    target_name: str,
    packet_name: str,
    num_packets: int,
    timeout: float,
    polling_rate: float = DEFAULT_TLM_POLLING_RATE,
    quiet: bool = True,
) -> float:
    """
    Pauses the script until a certain number of packets have been received, stopping on timeout.
    """
    ...

# --- Limits ---

@overload
def limits_enabled(telemetry_item: str) -> bool: ...
@overload
def limits_enabled(target_name: str, packet_name: str, item_name: str) -> bool: ...
def limits_enabled(*args) -> bool:
    """
    Returns true/false depending on whether limits are enabled for a telemetry item.
    """
    ...

@overload
def enable_limits(telemetry_item: str) -> None: ...
@overload
def enable_limits(target_name: str, packet_name: str, item_name: str) -> None: ...
def enable_limits(*args) -> None:
    """
    Enables limits monitoring for the specified telemetry item.
    """
    ...

@overload
def disable_limits(telemetry_item: str) -> None: ...
@overload
def disable_limits(target_name: str, packet_name: str, item_name: str) -> None: ...
def disable_limits(*args) -> None:
    """
    Disables limits monitoring for the specified telemetry item.
    """
    ...

def enable_limits_group(limits_group_name: str) -> None:
    """
    Enables limits monitoring on a set of telemetry items specified in a limits group.
    """
    ...

def disable_limits_group(limits_group_name: str) -> None:
    """
    Disables limits monitoring on a set of telemetry items specified in a limits group.
    """
    ...

def get_limits_groups() -> List[str]:
    """
    Returns the list of limits groups in the system.
    """
    ...

def set_limits_set(limits_set_name: str) -> None:
    """
    Sets the current limits set.
    """
    ...

def get_limits_set() -> str:
    """
    Returns the name of the current limits set.
    """
    ...

def get_limits_sets() -> List[str]:
    """
    Returns the list of limits sets in the system.
    """
    ...

@overload
def get_limits(telemetry_item: str) -> Dict[str, List[float]]: ...
@overload
def get_limits(
    target_name: str, packet_name: str, item_name: str
) -> Dict[str, List[float]]: ...
def get_limits(*args) -> Dict[str, List[float]]:
    """
    Returns hash / dict of all the limits settings for a telemetry point.
    """
    ...

@overload
def set_limits(
    target_name: str,
    packet_name: str,
    item_name: str,
    red_low: float,
    yellow_low: float,
    yellow_high: float,
    red_high: float,
    green_low: Optional[float] = None,
    green_high: Optional[float] = None,
    limits_set: Optional[str] = None,
    persistence: Optional[int] = None,
    enabled: Optional[bool] = None,
) -> None: ...
def set_limits(*args, **kwargs) -> None:
    """
    Sets limits settings for a telemetry point.
    """
    ...

def get_out_of_limits() -> List[Dict[str, str]]:
    """
    Returns an array with the target_name, packet_name, item_name, and limits_state of all items that are out of their limits ranges.
    """
    ...

def get_overall_limits_state(ignored_items: Optional[List[List[str]]] = None) -> str:
    """
    Returns the overall limits state for the COSMOS system.
    """
    ...

def get_limits_events(
    offset: Optional[str] = None, count: int = 100
) -> List[Tuple[str, Dict[str, Any]]]:
    """
    Returns limits events based on an offset returned from the last time it was called.
    """
    ...

# --- Plugins / Packages ---

def plugin_list(default: bool = False) -> List[str]:
    """
    Returns all the installed plugins.
    """
    ...

def plugin_get(plugin_name: str) -> Dict[str, Any]:
    """
    Returns information about an installed plugin.
    """
    ...

def package_list() -> Dict[str, List[str]]:
    """
    List all the packages installed in COSMOS.
    """
    ...

# --- Targets ---

def get_target_names() -> List[str]:
    """
    Returns a list of the targets in the system.
    """
    ...

def get_target(target_name: str) -> Dict[str, Any]:
    """
    Returns a target hash containing all the information about the target.
    """
    ...

def get_target_interfaces() -> List[Tuple[str, str]]:
    """
    Returns the interfaces for all targets.
    """
    ...

# --- Interfaces ---

def get_interface(interface_name: str) -> Dict[str, Any]:
    """
    Returns an interface status including the as-built interface and its current status.
    """
    ...

def get_interface_names() -> List[str]:
    """
    Returns a list of the interfaces in the system.
    """
    ...

@overload
def connect_interface(interface_name: str) -> None:
    """
    Connects to targets associated with a COSMOS interface.
    """
    ...

@overload
def connect_interface(interface_name: str, *args: Any) -> None:
    """
    Connects to targets associated with a COSMOS interface with specific parameters.
    """
    ...

def connect_interface(*args: Any, **kwargs: Any) -> None: ...
def disconnect_interface(interface_name: str) -> None:
    """
    Disconnects from targets associated with a COSMOS interface.
    """
    ...

def start_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Starts logging of raw data on one or all interfaces.
    """
    ...

def stop_raw_logging_interface(interface_name: str = "ALL") -> None:
    """
    Stops logging of raw data on one or all interfaces.
    """
    ...

def get_all_interface_info() -> (
    List[Tuple[str, str, int, int, int, int, int, int, int]]
):
    """
    Returns information about all interfaces. The return value is an array of arrays where each
    subarray contains the interface name, connection state, number of connected clients, transmit queue size,
    receive queue size, bytes transmitted, bytes received, command count, and telemetry count.
    """
    ...

def map_target_to_interface(
    target_name: str,
    interface_name: str,
    cmd_only: bool = False,
    tlm_only: bool = False,
    unmap_old: bool = True,
) -> None:
    """
    Map a target to an interface allowing target commands and telemetry to be processed by that interface.
    """
    ...

def interface_cmd(
    interface_name: str, command_name: str, command_parameters: Optional[str] = None
) -> None:
    """
    Send a command directly to an interface.
    """
    ...

def interface_protocol_cmd(
    interface_name: str,
    command_name: str,
    command_parameters: Optional[str] = None,
    read_write: str = "READ_WRITE",
    index: int = -1,
) -> None:
    """
    Send a command directly to an interface protocol.
    """
    ...

# --- Routers ---

@overload
def connect_router(router_name: str) -> None: ...
@overload
def connect_router(router_name: str, *args: Any) -> None: ...
def connect_router(*args: Any, **kwargs: Any) -> None:
    """
    Connects a COSMOS router.

    Args:
        router_name (str): The name of the router.
        *args: Optional parameters used to initialize the router.
    """
    ...

def disconnect_router(router_name: str) -> None:
    """
    Disconnects a COSMOS router.

    Args:
        router_name (str): The name of the router.
    """
    ...

def get_router_names() -> List[str]:
    """
    Returns a list of the routers in the system.
    """
    ...

def get_router(router_name: str) -> Dict[str, Any]:
    """
    Returns a router status including the as-built router and its current status.

    Args:
        router_name (str): The name of the router.
    """
    ...

def get_all_router_info() -> List[Tuple[str, str, int, int, int, int, int, int, int]]:
    """
    Returns information about all routers. The return value is a list of tuples where each tuple
    contains the router name, connection state, number of connected clients, transmit queue size,
    receive queue size, bytes transmitted, bytes received, packets received, and packets sent.
    """
    ...

def start_raw_logging_router(router_name: str = "ALL") -> None:
    """
    Starts logging of raw data on one or all routers.

    Args:
        router_name (str, optional): Name of the router to start logging. Defaults to 'ALL'.
    """
    ...

def stop_raw_logging_router(router_name: str = "ALL") -> None:
    """
    Stops logging of raw data on one or all routers.

    Args:
        router_name (str, optional): Name of the router to stop logging. Defaults to 'ALL'.
    """
    ...

def router_cmd(
    router_name: str, command_name: str, command_parameters: Optional[str] = None
) -> None:
    """
    Send a command directly to a router.

    Args:
        router_name (str): The name of the router.
        command_name (str): The name of the command to send.
        command_parameters (str, optional): Any parameters to send with the command.
    """
    ...

def router_protocol_cmd(
    router_name: str,
    command_name: str,
    command_parameters: Optional[str] = None,
    read_write: str = "READ_WRITE",
    index: int = -1,
) -> None:
    """
    Send a command directly to a router protocol.

    Args:
        router_name (str): The name of the router.
        command_name (str): The name of the command to send.
        command_parameters (str, optional): Any parameters to send with the command.
        read_write (str, optional): 'READ', 'WRITE', or 'READ_WRITE'. Defaults to 'READ_WRITE'.
        index (int, optional): The protocol index in the stack. Defaults to -1 (all).
    """
    ...

# --- Tables ---

def table_create_binary(table_definition_file: str) -> Dict[str, str]:
    """
    Creates a table binary based on a table definition file.

    Args:
        table_definition_file (str): Path to the table definition file, e.g., 'INST/tables/config/ConfigTables_def.txt'

    Returns:
        Dict[str, str]: A dictionary containing the path to the created binary file, e.g., {'filename': '...'}
    """
    ...

def table_create_report(
    table_binary_file: str, table_definition_file: str, table_name: Optional[str] = None
) -> Dict[str, str]:
    """
    Creates a report from a table binary based on a table definition file.

    Args:
        table_binary_file (str): Path to the table binary file, e.g., 'INST/tables/bin/ConfigTables.bin'
        table_definition_file (str): Path to the table definition file, e.g., 'INST/tables/config/ConfigTables_def.txt'
        table_name (Optional[str]): The name of the specific table to create a report for. If not provided, a report for all tables in the file is generated.

    Returns:
        Dict[str, str]: A dictionary containing the filename and the contents of the generated report, e.g., {'filename': '...', 'contents': '...'}
    """
    ...

# --- Stashing Data ---

def stash_set(stash_key: str, stash_value: Any) -> None:
    """
    Sets a stash item.

    Args:
        stash_key (str): Name of the stash key to set.
        stash_value (Any): Value to set.
    """
    ...

def stash_get(stash_key: str) -> Any:
    """
    Returns the specified stash item.

    Args:
        stash_key (str): Name of the stash key to return.

    Returns:
        Any: The value of the stash item.
    """
    ...

def stash_all() -> Dict[str, Any]:
    """
    Returns all the stash items as a dictionary.

    Returns:
        Dict[str, Any]: A dictionary containing all stash items.
    """
    ...

def stash_keys() -> List[str]:
    """
    Returns all the stash keys.

    Returns:
        List[str]: A list of all stash keys.
    """
    ...

def stash_delete(stash_key: str) -> None:
    """
    Deletes a stash item.

    Args:
        stash_key (str): Name of the stash key to delete.
    """
    ...

# --- Telemetry Screens ---

def display_screen(
    target_name: str,
    screen_name: str,
    x_position: Optional[int] = None,
    y_position: Optional[int] = None,
) -> None:
    """
    Opens a telemetry screen at the specified position.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
        x_position (Optional[int]): X coordinate for the upper-left corner of the screen.
        y_position (Optional[int]): Y coordinate for the upper-left corner of the screen.
    """
    ...

def clear_screen(target_name: str, screen_name: str) -> None:
    """
    Closes an open telemetry screen.

    Args:
        target_name (str): Telemetry screen target name. For local screens, the target is 'LOCAL'.
        screen_name (str): Screen name within the specified target.
    """
    ...

def clear_all_screens() -> None:
    """
    Closes all open screens.
    """
    ...

def delete_screen(target_name: str, screen_name: str) -> None:
    """
    Deletes an existing Telemetry Viewer screen.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
    """
    ...

def get_screen_list() -> List[str]:
    """
    Returns a list of available telemetry screens.
    """
    ...

def get_screen_definition(target_name: str, screen_name: str) -> str:
    """
    Returns the text file contents of a telemetry screen definition.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.

    Returns:
        str: The entire screen definition as a string.
    """
    ...

def create_screen(target_name: str, screen_name: str, definition: str) -> None:
    """
    Allows you to create a screen directly from a script. This screen is saved to
    Telemetry Viewer for future use.

    Args:
        target_name (str): Telemetry screen target name.
        screen_name (str): Screen name within the specified target.
        definition (str): The entire screen definition as a string.
    """
    ...

def local_screen(
    screen_name: str,
    definition: str,
    x_position: Optional[int] = None,
    y_position: Optional[int] = None,
) -> None:
    """
    Allows you to create a local screen directly from a script which is not
    permanently saved to the Telemetry Viewer screen list.

    Args:
        screen_name (str): Screen name.
        definition (str): The entire screen definition as a string.
        x_position (Optional[int]): X coordinate for the upper-left corner of the screen.
        y_position (Optional[int]): Y coordinate for the upper-left corner of the screen.
    """
    ...

# --- Script Runner Scripts ---

def start(procedure_filename: str) -> None:
    """
    Starts execution of another high-level test procedure.

    Args:
        procedure_filename (str): Name of the test procedure file.
    """
    ...

@overload
def goto(line_number: int) -> None: ...
@overload
def goto(filename: str, line_number: int) -> None: ...
def goto(arg1, arg2: Optional[int] = None) -> None:
    """
    Jumps to a specific line in either the current file or another file.

    Args:
        arg1 (Union[int, str]): The line number to jump to in the current file, or the filename to jump to.
        arg2 (Optional[int]): The line number in the specified file.
    """
    ...

def load_utility(utility_filename: str) -> None:
    """
    Reads in a script file that contains useful subroutines.

    Args:
        utility_filename (str): Name of the script file containing subroutines, including the full path.
    """
    ...

def script_list() -> List[str]:
    """
    Returns all the available files in COSMOS as a list.
    """
    ...

def script_create(script_name: str, script_contents: str) -> None:
    """
    Creates a new script with the given contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
        script_contents (str): Script contents as text.
    """
    ...

def script_body(script_name: str) -> str:
    """
    Returns the script contents.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_delete(script_name: str) -> None:
    """
    Deletes a script from COSMOS.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_run(
    script_name: str,
    disconnect: bool = False,
    environment: Optional[Dict[str, str]] = None,
    suite_runner: Optional[Dict[str, str]] = None,
) -> str:
    """
    Runs a script in Script Runner.

    Args:
        script_name (str): Full path name of the script starting with the target.
        disconnect (bool): Whether to run the script in Disconnect mode.
        environment (Optional[Dict[str, str]]): A dictionary of key/value items to set as script environment variables.
        suite_runner (Optional[Dict[str, str]]): A dictionary of suite runner options.

    Returns:
        str: The ID of the started script.
    """
    ...

def script_lock(script_name: str) -> None:
    """
    Locks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_unlock(script_name: str) -> None:
    """
    Unlocks a script for editing.

    Args:
        script_name (str): Full path name of the script starting with the target.
    """
    ...

def script_syntax_check(script_name: str) -> Dict[str, Any]:
    """
    Performs a Ruby or Python syntax check on the given script.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        Dict[str, Any]: A dictionary containing the syntax check result.
    """
    ...

def script_instrumented(script_name: str) -> str:
    """
    Returns the instrumented script which allows COSMOS Script Runner to monitor
    the execution.

    Args:
        script_name (str): Full path name of the script starting with the target.

    Returns:
        str: The instrumented script contents.
    """
    ...

def script_delete_all_breakpoints() -> None:
    """
    Deletes all breakpoints associated with all scripts.
    """
    ...

def step_mode() -> None:
    """
    Places ScriptRunner into step mode.
    """
    ...

def run_mode() -> None:
    """
    Places ScriptRunner into run mode.
    """
    ...

def disconnect_script() -> None:
    """
    Puts scripting into disconnect mode.
    """
    ...

def running_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the currently running scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a running script.
    """
    ...

def script_get(script_id: str) -> Dict[str, Any]:
    """
    Gets information on the script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.

    Returns:
        Dict[str, Any]: A dictionary containing information about the script.
    """
    ...

def running_script_stop(script_id: str) -> None:
    """
    Stops the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_pause(script_id: str) -> None:
    """
    Pauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_retry(script_id: str) -> None:
    """
    Retries the current line of the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_go(script_id: str) -> None:
    """
    Unpauses the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int
) -> None: ...
@overload
def running_script_execute_while_paused(
    script_id: str, script_file_path: str, start_line_number: int, end_line_number: int
) -> None: ...
def running_script_execute_while_paused(
    script_id: str,
    script_file_path: str,
    start_line_number: int,
    end_line_number: Optional[int] = None,
) -> None:
    """
    Performs a goto or executes a selection on a running script.

    Args:
        script_id (str): Script ID returned by script_run.
        script_file_path (str): Path to the script file.
        start_line_number (int): The line number to start at.
        end_line_number (Optional[int]): The line number to end at. If given, executes a selection.
    """
    ...

def running_script_step(script_id: str) -> None:
    """
    Steps the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def running_script_delete(script_id: str) -> None:
    """
    Force quits the running script with the specified ID.

    Args:
        script_id (str): Script ID returned by script_run.
    """
    ...

def completed_script_list(limit: int = 10, offset: int = 0) -> List[Dict[str, Any]]:
    """
    Lists the completed scripts.

    Args:
        limit (int): Max number to return.
        offset (int): Offset into the list to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, each representing a completed script.
    """
    ...

# --- Script Runner Settings ---

def set_line_delay(delay: float) -> None:
    """
    Sets the line delay in Script Runner.

    Args:
        delay (float): The amount of time Script Runner will wait between
                       lines when executing a script, in seconds. Must be >= 0.0.
    """
    ...

def get_line_delay() -> float:
    """
    Gets the line delay that Script Runner is currently using.

    Returns:
        float: The current line delay in seconds.
    """
    ...

def set_max_output(characters: int) -> None:
    """
    Sets the maximum number of characters to display in Script Runner output.

    Args:
        characters (int): The maximum number of characters to output before truncating.
    """
    ...

def get_max_output() -> int:
    """
    Gets the maximum number of characters to display in Script Runner output.

    Returns:
        int: The maximum number of characters.
    """
    ...

def disable_instrumentation() -> Iterator[None]:
    """
    Disables instrumentation (line highlighting and exception catching) for a block of code.
    Use with a 'with' statement.

    Example:
        with disable_instrumentation():
            for x in range(1000):
                # This loop will not be instrumented
                pass
    """
    yield

# --- Base classes from the OpenC3 library ---

class Group:
    """
    Base class for defining a group of tests within a test suite.

    This class provides a structure for grouping related tests and
    can include optional `setup` and `teardown` methods that run
    before and after the tests in the group.
    """

    def setup(self) -> None:
        """
        Method that runs before any scripts in the group.
        """
        pass

    def teardown(self) -> None:
        """
        Method that runs after all scripts in the group.
        """
        pass

class Suite:
    """
    Base class for defining a test suite.

    A test suite is a collection of groups and individual scripts
    that can be executed together.
    """

    def __init__(self) -> None:
        pass

    def add_group(self, group_class: Type[Group]) -> None:
        """
        Adds all the methods of a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class to add.
        """
        pass

    def add_group_setup(self, group_class: Type[Group]) -> None:
        """
        Adds just the 'setup' method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the 'setup' method.
        """
        pass

    def add_group_teardown(self, group_class: Type[Group]) -> None:
        """
        Adds just the 'teardown' method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the 'teardown' method.
        """
        pass

    def add_script(self, group_class: Type[Group], method_name: str) -> None:
        """
        Adds a single method from a Group class to the suite.

        Args:
            group_class (Type[Group]): The Group class containing the method.
            method_name (str): The name of the method to add.
        """
        pass

# --- Timelines ---
from datetime import datetime

def list_timelines() -> List[Dict[str, Any]]:
    """
    Returns a list of all timelines in the system.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a timeline.
    """
    ...

def create_timeline(name: str, color: Optional[str] = None) -> Dict[str, Any]:
    """
    Creates a new timeline in Calendar.

    Args:
        name (str): The name of the timeline.
        color (Optional[str]): The color of the timeline as a hex value (e.g., '#FF0000').
                               Defaults to a random color.

    Returns:
        Dict[str, Any]: A dictionary representing the created timeline.
    """
    ...

def get_timeline(name: str) -> Dict[str, Any]:
    """
    Gets information about an existing timeline.

    Args:
        name (str): The name of the timeline.

    Returns:
        Dict[str, Any]: A dictionary representing the timeline.
    """
    ...

def set_timeline_color(name: str, color: str) -> None:
    """
    Sets the displayed color for an existing timeline.

    Args:
        name (str): The name of the timeline.
        color (str): The color of the timeline as a hex value (e.g., '#4287f5').
    """
    ...

def delete_timeline(name: str, force: bool = False) -> None:
    """
    Deletes an existing timeline.

    Args:
        name (str): The name of the timeline.
        force (bool): If True, deletes the timeline even if it has activities.
                      Defaults to False.
    """
    ...

def create_timeline_activity(
    name: str, kind: str, start: datetime, stop: datetime, data: Dict[str, Any] = {}
) -> Dict[str, Any]:
    """
    Creates an activity on an existing timeline.

    Args:
        name (str): The name of the timeline.
        kind (str): The type of the activity. Must be one of 'COMMAND', 'SCRIPT', or 'RESERVE'.
        start (datetime): The start time of the activity.
        stop (datetime): The stop time of the activity.
        data (Dict[str, Any]): A dictionary of data for COMMAND or SCRIPT activities.
                               Defaults to an empty dictionary.

    Returns:
        Dict[str, Any]: A dictionary representing the created activity.
    """
    ...

def get_timeline_activity(name: str, start: datetime, uuid: str) -> Dict[str, Any]:
    """
    Gets an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.

    Returns:
        Dict[str, Any]: A dictionary representing the activity.
    """
    ...

def get_timeline_activities(
    name: str,
    start: Optional[datetime] = None,
    stop: Optional[datetime] = None,
    limit: Optional[int] = None,
) -> List[Dict[str, Any]]:
    """
    Gets a range of timeline activities.

    Args:
        name (str): The name of the timeline.
        start (Optional[datetime]): The start time of the activities. Defaults to 7 days ago.
        stop (Optional[datetime]): The stop time of the activities. Defaults to 7 days from now.
        limit (Optional[int]): The maximum number of activities to return.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary represents an activity.
    """
    ...

def delete_timeline_activity(name: str, start: datetime, uuid: str) -> None:
    """
    Deletes an existing timeline activity.

    Args:
        name (str): The name of the timeline.
        start (datetime): The start time of the activity.
        uuid (str): The UUID of the activity.
    """
    ...

# --- Metadata ---

def metadata_all(limit: int = 100) -> List[Dict[str, Any]]:
    """
    Returns all the metadata that was previously set.

    Args:
        limit (int): The maximum number of metadata items to return. Defaults to 100.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_get(start: str) -> List[Dict[str, Any]]:
    """
    Returns metadata that was previously set, starting from a specified time.

    Args:
        start (str): Time at which to retrieve metadata as an integer or string
                     representing seconds from epoch.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries representing the metadata.
    """
    ...

def metadata_set(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Sets metadata which appears in the Calendar tool.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to store as metadata.
        start (Optional[datetime]): Time at which to store the metadata. Defaults to now.
        color (Optional[str]): Color to display the metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_update(
    metadata: Dict[str, Any],
    start: Optional[datetime] = None,
    color: Optional[str] = None,
) -> None:
    """
    Updates metadata that was previously set.

    Args:
        metadata (Dict[str, Any]): A dictionary of key-value pairs to update as metadata.
        start (Optional[datetime]): Time at which to update metadata. Defaults to the
                                    latest metadata item.
        color (Optional[str]): Color to display metadata in the calendar.
                               Defaults to '#003784'.
    """
    ...

def metadata_input() -> Dict[str, Any]:
    """
    Prompts the user to set existing metadata values or create a new one.

    Returns:
        Dict[str, Any]: A dictionary containing the metadata entered by the user.
    """
    ...

# --- Settings ---

def list_settings() -> List[str]:
    """
    Returns all the current COSMOS setting names.

    Returns:
        List[str]: A list of strings representing the names of the available settings.
    """
    ...

def get_all_settings() -> Dict[str, Any]:
    """
    Returns all the current COSMOS settings along with their values.

    Returns:
        Dict[str, Any]: A dictionary where keys are setting names and values are
                        dictionaries containing the setting data.
    """
    ...

def get_setting(setting_name: str) -> Optional[Any]:
    """
    Returns the value of a specific COSMOS setting.

    Args:
        setting_name (str): The name of the setting.

    Returns:
        Optional[Any]: The value of the setting, or None if the setting does not exist.
    """
    ...

def get_settings(*setting_names: str) -> List[Optional[Any]]:
    """
    Returns the data from one or more COSMOS settings.

    Args:
        *setting_names (str): The names of the settings to return.

    Returns:
        List[Optional[Any]]: A list containing the values of the requested settings.
                             The order matches the input order.
    """
    ...

def set_setting(setting_name: str, setting_value: Any) -> None:
    """
    Sets the value for a given setting.

    NOTE: This API is only accessible externally (not within Script Runner)
          and requires the admin password.

    Args:
        setting_name (str): The name of the setting to change.
        setting_value (Any): The new value for the setting.
    """
    ...

# --- Configuration ---

def config_tool_names() -> List[str]:
    """
    Returns a list of all available configuration tool names.

    Returns:
        List[str]: A list of strings representing the tool names.
    """
    ...

def list_configs(tool_name: str) -> List[str]:
    """
    Lists all saved configuration names for a given tool.

    Args:
        tool_name (str): The name of the tool.

    Returns:
        List[str]: A list of strings representing the configuration names.
    """
    ...

def load_config(tool_name: str, config_name: str) -> List[Dict[str, Any]]:
    """
    Loads a specific tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.

    Returns:
        List[Dict[str, Any]]: The configuration data as a list of dictionaries.
    """
    ...

def save_config(tool_name: str, config_name: str, config_data: Any) -> None:
    """
    Saves a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        config_data (Any): The configuration data to save.
    """
    ...

def delete_config(tool_name: str, config_name: str, local_mode: bool = False) -> None:
    """
    Deletes a particular tool configuration.

    Args:
        tool_name (str): The name of the tool.
        config_name (str): The name of the configuration.
        local_mode (bool): Whether the configuration is in local mode.
                           Defaults to False.
    """
    ...

# --- Offline Access ---

def initialize_offline_access() -> None:
    """
    Creates and sets the offline access token for the user.

    NOTE: This method must be called outside of Script Runner before
    executing any API methods that require an offline access token, such
    as `script_run`.
    """
    ...

def offline_access_needed() -> bool:
    """
    Checks if the user needs to generate an offline access token.

    Returns:
        bool: True if an offline access token is needed for the user,
              False otherwise.
    """
    ...

def set_offline_access(offline_access_token: str) -> None:
    """
    Sets the offline access token in the backend.

    NOTE: You probably won't need to call this method directly, as it is
    automatically called by `initialize_offline_access()`.

    Args:
        offline_access_token (str): The Keycloak-generated refresh token
                                    with the `offline_access` openid scope.
    """
    ...

# --- Autonomic Groups ---

def autonomic_group_list(scope: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Returns a list of all autonomic groups.

    Args:
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents an autonomic group.
    """
    ...

def autonomic_group_create(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Creates a new autonomic group.

    Args:
        name (str): The name of the group to create.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created group.
    """
    ...

def autonomic_group_show(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Shows details about a specific autonomic group.

    Args:
        name (str): The name of the group.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the group.
    """
    ...

def autonomic_group_destroy(name: str, scope: Optional[str] = None) -> None:
    """
    Destroys an autonomic group.

    Args:
        name (str): The name of the group to destroy.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

# --- Autonomic Triggers ---

def autonomic_trigger_list(
    group: str = "DEFAULT", scope: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Returns a list of triggers in a specific group.

    Args:
        group (str): The group to list triggers from. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a trigger.
    """
    ...

def autonomic_trigger_create(
    left: Dict[str, Any],
    operator: str,
    right: Dict[str, Any],
    group: str = "DEFAULT",
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Creates a new trigger with the specified condition.

    Args:
        left (Dict[str, Any]): The left side of the trigger condition.
        operator (str): The comparison operator (e.g., '>', '<', '==').
        right (Dict[str, Any]): The right side of the trigger condition.
        group (str): The group to create the trigger in. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created trigger.
    """
    ...

def autonomic_trigger_show(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> Dict[str, Any]:
    """
    Shows details about a specific trigger.

    Args:
        name (str): The name of the trigger.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the trigger.
    """
    ...

def autonomic_trigger_enable(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Enables a trigger.

    Args:
        name (str): The name of the trigger to enable.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_trigger_disable(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Disables a trigger.

    Args:
        name (str): The name of the trigger to disable.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_trigger_update(
    name: str,
    group: str = "DEFAULT",
    left: Optional[Dict[str, Any]] = None,
    operator: Optional[str] = None,
    right: Optional[Dict[str, Any]] = None,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Updates an existing trigger with new parameters.

    Args:
        name (str): The name of the trigger to update.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        left (Dict[str, Any], optional): The new left side of the condition.
        operator (str, optional): The new comparison operator.
        right (Dict[str, Any], optional): The new right side of the condition.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the updated trigger.
    """
    ...

def autonomic_trigger_destroy(
    name: str, group: str = "DEFAULT", scope: Optional[str] = None
) -> None:
    """
    Destroys a trigger.

    Args:
        name (str): The name of the trigger to destroy.
        group (str): The group the trigger belongs to. Defaults to 'DEFAULT'.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

# --- Autonomic Reactions ---

def autonomic_reaction_list(scope: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    Returns a list of all reactions.

    Args:
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
                              represents a reaction.
    """
    ...

def autonomic_reaction_create(
    triggers: List[Dict[str, str]],
    actions: List[Dict[str, str]],
    trigger_level: str = "EDGE",
    snooze: int = 0,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Creates a new reaction that executes actions when triggers are activated.

    Args:
        triggers (List[Dict[str, str]]): A list of trigger names that activate this reaction.
        actions (List[Dict[str, str]]): A list of actions to perform when triggered.
        trigger_level (str): The trigger level ('EDGE' or 'LEVEL'). Defaults to 'EDGE'.
        snooze (int): The snooze time in seconds between activations. Defaults to 0.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the created reaction.
    """
    ...

def autonomic_reaction_show(name: str, scope: Optional[str] = None) -> Dict[str, Any]:
    """
    Shows details about a specific reaction.

    Args:
        name (str): The name of the reaction.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing details about the reaction.
    """
    ...

def autonomic_reaction_enable(name: str, scope: Optional[str] = None) -> None:
    """
    Enables a reaction.

    Args:
        name (str): The name of the reaction to enable.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_disable(name: str, scope: Optional[str] = None) -> None:
    """
    Disables a reaction.

    Args:
        name (str): The name of the reaction to disable.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_execute(name: str, scope: Optional[str] = None) -> None:
    """
    Manually executes a reaction's actions.

    Args:
        name (str): The name of the reaction to execute.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...

def autonomic_reaction_update(
    name: str,
    triggers: Optional[List[Dict[str, str]]] = None,
    actions: Optional[List[Dict[str, str]]] = None,
    trigger_level: Optional[str] = None,
    snooze: Optional[int] = None,
    scope: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Updates an existing reaction with new parameters.

    Args:
        name (str): The name of the reaction to update.
        triggers (List[Dict[str, str]], optional): New list of trigger names.
        actions (List[Dict[str, str]], optional): New list of actions.
        trigger_level (str, optional): New trigger level.
        snooze (int, optional): New snooze time in seconds.
        scope (str, optional): The scope to operate in. Defaults to None.

    Returns:
        Dict[str, Any]: A dictionary containing information about the updated reaction.
    """
    ...

def autonomic_reaction_destroy(name: str, scope: Optional[str] = None) -> None:
    """
    Destroys a reaction.

    Args:
        name (str): The name of the reaction to destroy.
        scope (str, optional): The scope to operate in. Defaults to None.
    """
    ...
